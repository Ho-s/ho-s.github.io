<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.4846721b3cfc3117aa50.css" id="gatsby-global-css">@font-face{font-family:s-core-dream-thin;src:url(/static/scdream1-webfont-a6745ebe1579e79a9e652c2d10a7d7b2.woff2) format("woff2"),url(/static/scdream1-webfont-4ba54d00783c86ec9cf675931ffa65f7.woff) format("woff");font-weight:400;font-style:normal}@font-face{font-family:s-core-dream-extralight;src:url(/static/scdream2-webfont-ed03db51f4f73df6ffa1265462a27c2e.woff2) format("woff2"),url(/static/scdream2-webfont-acb73baacc7d62dbd30fd66221c797c7.woff) format("woff");font-weight:400;font-style:normal}@font-face{font-family:s-core-dream-light;src:url(/static/scdream3-webfont-4d4fc2882311934c6b661a87957fbc73.woff2) format("woff2"),url(/static/scdream3-webfont-dcd4d167d85605718e7eff8e0b2f9ed9.woff) format("woff");font-weight:400;font-style:normal}@font-face{font-family:s-core-dream-regular;src:url(/static/scdream4-webfont-8cbe0f0b35e866fdae7b44f27e1ed175.woff2) format("woff2"),url(/static/scdream4-webfont-f143b980a8d84f334609a1fc517436fc.woff) format("woff");font-weight:400;font-style:normal}@font-face{font-family:s-core-dream-medium;src:url(/static/scdream5-webfont-c828c3e71e27b0ece1ff63c7b3428ce2.woff2) format("woff2"),url(/static/scdream5-webfont-6b9a81a834b738576fc012f92daf1323.woff) format("woff");font-weight:400;font-style:normal}@font-face{font-family:s-core-dream-bold;src:url(/static/scdream6-webfont-6a50140f00a5e843fc6ba5fb163193fd.woff2) format("woff2"),url(/static/scdream6-webfont-d1e9632a045de315e440824af73adfdc.woff) format("woff");font-weight:400;font-style:normal}@font-face{font-family:s-core-dream-extrabold;src:url(/static/scdream7-webfont-7d4dd521e796c2a45dbb6c6ce5a1f760.woff2) format("woff2"),url(/static/scdream7-webfont-03f45259b8fae3d7f9e4d0dbcf163535.woff) format("woff");font-weight:400;font-style:normal}@font-face{font-family:s-core-dream-heavy;src:url(/static/scdream8-webfont-ec791200ec19760c7f81e3dc6bb4c0ce.woff2) format("woff2"),url(/static/scdream8-webfont-987bc055fce3dec989a7c15aeb6d1f3d.woff) format("woff");font-weight:400;font-style:normal}@font-face{font-family:s-core-dream-black;src:url(/static/scdream9-webfont-860c885b742fcf3c630e197360efd3b3.woff2) format("woff2"),url(/static/scdream9-webfont-fcc588fbb02f18590f2d791227b47201.woff) format("woff");font-weight:400;font-style:normal}html{box-sizing:border-box;overflow-y:auto;overflow-y:overlay;overflow-x:hidden;min-width:300px;scroll-behavior:smooth}#nav li a,#topbar,#wpmem_login,#wpmem_reg,.dwqa-container,.wf-container>*,.widget-title,a,body,button,h1,h2,h3,h4,h5,h6,input,li,p,select,textarea{font-family:s-core-dream-light,sans-serif!important}body{margin:0}::-webkit-scrollbar-track{background-color:#fff;border-radius:10px;box-shadow:inset 0 0 5px #fff}::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{background-color:#000;border-radius:10px;background-clip:padding-box;border:2px solid transparent}#gatsby-focus-wrapper{position:relative;min-height:90vh}hr{margin:0 auto;padding:0;border-top:1px solid grey;opacity:.2}img{max-width:100%}.markdown:hover{box-shadow:5px 5px 2px 1px #e9e9e9}.markdownTemplate a{text-decoration:none;color:#00f}.header-link:hover{font-weight:600;color:red!important}.index-main{width:260px;top:-400px;line-height:2.12;font-size:47px;text-decoration:none}.index-introduction,.index-main{height:100px;margin:auto;position:absolute;left:0;right:0;bottom:0;color:#fff;text-align:center}.index-introduction{width:200px;top:300px}.fa-facebook-f,.fa-git,.fa-google-plus-g{margin-bottom:20px;float:left;text-decoration:none;width:40px;height:40px;text-align:center;line-height:40px;border:2px solid #fff;border-radius:40px;background-color:transparent;font-size:25px;transition:all .2s}.fa-facebook-f:before,.fa-git:before,.fa-google-plus-g:before{font-family:Font Awesome\ 5 Brands;color:#fff;transition:all .2s;content:""}.fa-git:hover{background-color:#fff}.fa-git:hover:before{color:#000}.fa-facebook-f:hover{background-color:#fff}.fa-facebook-f:hover:before{color:#000}.fa-google-plus-g:hover{background-color:#fff}.fa-google-plus-g:hover:before{color:#000}.header-title span{transition:all .2s}.header-title:hover span{font-weight:bolder;color:red}.index-more:before{content:"▶";color:#000;position:absolute;right:-100px;opacity:0;top:-7px;font-size:20px;transition:.2s}.index-more:hover{margin-right:20px}.index-more:hover:before{opacity:1;right:-20px}.toTheTop:hover{background-color:violet!important}.index-project:hover{box-shadow:5px 5px 2px 1px #e9e9e9}.contents{position:fixed;width:325px;right:100px;top:100px;height:325px;overflow-y:auto;overflow-x:hidden}.contents a:hover{color:#000}.contents a{overflow:hidden;text-overflow:ellipsis;height:15px;white-space:nowrap}.contents ul li{list-style:none}.contents ul li a{color:grey}.contents ul:first-child{font-size:12px;padding-left:3px;margin:0;border-left:3px solid #e9e9e9;font-weight:600}.contents p{margin:4px 0}.introduction{height:540px}.projects{height:250px}.blog-btn{color:#e9e9e9}.blog-btn:hover{color:#000}footer{width:calc(100% - 40vw);padding:1.6vw 20vw}header{padding-left:5vw;padding-right:5vw;width:90vw}blockquote{background-color:#e9e9e9;position:relative;padding:3px 15px;border-left:3px solid green}table{display:block;width:100%;overflow:auto}table th{font-weight:600}table td,table th{padding:6px 13px;border:1px solid #dfe2e5}table tr{background-color:#fff;border-top:1px solid #c6cbd1}thead th{background-color:#e9e9e9}@media screen and (max-width:1750px){.contents{right:0}}@media screen and (max-width:1640px){.contents{display:none}}@media screen and (max-width:1300px){nav{opacity:0;left:-300px}}@media screen and (max-width:1020px){.introduction{height:1300px}.introduction ul{align-items:center;flex-direction:column}.introduction ul li{margin-top:15px}.projects ul li a div:nth-child(2),.projects ul li a div:nth-child(3){display:none}}@media screen and (max-width:512px){.toTheTop{display:none}footer{width:calc(100% - 20vw);padding:1.6vh 10vw}header{padding-left:1vw;padding-right:1vw;width:98vw}}code,pre{font-family:monospace;font-size:1em}pre{margin:0 0 1.45rem;font-size:.85rem;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}pre,pre code{line-height:1.42}pre code{background:none}code{font-size:.85rem;line-height:1.45rem;background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}code[class*=language-],pre[class*=language-]{color:#a9b7c6;font-family:Consolas,Monaco,Andale Mono,monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{color:inherit;background:rgba(33,66,131,.85)}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2b2b2b}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.prolog{color:grey}.token.comment{color:#556b2f}.token.atrule,.token.boolean,.token.delimiter,.token.important,.token.keyword,.token.selector{color:#cc7832}.token.attr-name,.token.operator,.token.punctuation{color:#a9b7c6}.token.builtin,.token.doctype,.token.tag,.token.tag .punctuation{color:#e8bf6a}.token.entity,.token.number,.token.symbol{color:#6897bb}.token.constant,.token.property,.token.variable{color:#9876aa}.token.char,.token.string{color:#6a8759}.token.attr-value,.token.attr-value .punctuation{color:#a5c261}.token.attr-value .punctuation:first-child{color:#a9b7c6}.token.url{color:#287bde;text-decoration:underline}.token.function{color:#ffc66d}.token.regex{background:#364135}.token.bold{font-weight:700}.token.italic{font-style:italic}.token.inserted{background:#294436}.token.deleted{background:#484a4a}code.language-css .token.property,code.language-css .token.property+.token.punctuation{color:#a9b7c6}code.language-css .token.id,code.language-css .token.selector>.token.attribute,code.language-css .token.selector>.token.class,code.language-css .token.selector>.token.pseudo-class,code.language-css .token.selector>.token.pseudo-element{color:#ffc66d}code[class*=language-text]{background-color:#e9e9e9!important;color:#000!important}</style><meta name="generator" content="Gatsby 3.3.1"/><title data-react-helmet="true"></title><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><link as="script" rel="preload" href="/webpack-runtime-e851f4dc4f972090e163.js"/><link as="script" rel="preload" href="/framework-75034fa8e3a9e81ff051.js"/><link as="script" rel="preload" href="/app-595cc7b5ec9c7c78be0e.js"/><link as="script" rel="preload" href="/component---markdown-template-js-20dc476c4a1ff5faaff2.js"/><link as="fetch" rel="preload" href="/page-data/technicalNote/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div style="position:fixed;width:100vw;height:100vh;background-color:white;z-index:4;top:0"><div style="margin:calc(50vh - 200px) auto;width:400px;height:400px;background-image:url(https://user-images.githubusercontent.com/71132893/104911800-c3520700-59ce-11eb-8448-35ab98a92bc6.gif);background-size:cover;background-repeat:no-repeat;background-position:center"></div></div><header style="padding-top:2.5vh;padding-bottom:2.5vh;position:absolute;top:90vh;left:0;transition:top .2s;color:white;min-width:400px"><div><a style="position:relative;text-decoration:none" href="/"><div style="top:0;filter:opacity(.6) drop-shadow(0 0 0 white);position:absolute;width:26px;height:26px;color:white;background-image:url(https://user-images.githubusercontent.com/71132893/103412811-4ba46f80-4bba-11eb-94b9-454fc8d16d8d.png);background-size:contain;background-repeat:no-repeat"></div><div class="header-title" style="line-height:1;position:absolute;width:90px;left:30px;color:white;font-size:27px"><span>Ho&#x27;space</span></div></a></div><div style="width:261px;margin:0;padding:0;list-style:none;float:right"><li><a class="header-link" style="float:left;margin-right:1rem;text-decoration:none;color:white;transition:color .1s linear" href="/about/">About</a></li><li><a class="header-link" style="float:left;margin-right:1rem;text-decoration:none;color:white;transition:color .1s linear" href="/projects/">Projects</a></li><li><a class="header-link" style="float:left;margin-right:1rem;text-decoration:none;color:white;transition:color .1s linear" href="/blog/">Blog</a></li><li><a class="header-link" style="float:left;margin-right:1rem;text-decoration:none;color:white;transition:color .1s linear" href="/contact/">Contact</a></li></div></header><div style="margin:0 auto;min-width:330px;max-width:990px;padding:0 1.0875rem 1.45rem;margin-top:10vh"><main><div class="markdownTemplate" style="position:relative;margin-bottom:200px;line-height:1.7"><h4 style="padding-bottom:5px;border-bottom:1px solid gray"><span style="color:gray">취업을 위한 TechnicalNote</span><span style="float:right;color:red">05 April, 2021</span></h4><div><h1 id="1-전산-기초" style="position:relative;"><a href="#1-%EC%A0%84%EC%82%B0-%EA%B8%B0%EC%B4%88" aria-label="1 전산 기초 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. 전산 기초</h1>
<h2 id="1-1-개발상식" style="position:relative;"><a href="#1-1-%EA%B0%9C%EB%B0%9C%EC%83%81%EC%8B%9D" aria-label="1 1 개발상식 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1-1. 개발상식</h2>
<h3 id="좋은-코드란-무엇인가" style="position:relative;"><a href="#%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="좋은 코드란 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>좋은 코드란 무엇인가</h3>
<ul>
<li>가독성이 뛰어나며, 중복이 없어야하며 등등이 있겠지만 개인적으로는 이것들은 모두 시간에 관한 부분이라고 생각한다.</li>
<li>가독성이 뛰어나다는 것은 클라이언트의 요구에 따라 코드를 변경을 할 때, 무엇을 바꿔야 할지 파악하는 데에 적은 시간이 들게하기 위한 것이고,</li>
<li>중복이 없어야한다는 것 또한, 수정을 요하는 곳이 있을 때 한 곳만 수정해도 정상적으로 작동이 되게끔함으로서 쓸 데 없는 시간 소비를 피하기 위한것이다.</li>
<li>그렇기 때문에 오류가 없는 정상적인 코드라고 한다면 개발부터 사후관리에 이르기까지 시간이 덜 드는 코드가 잘 짜여진 코드라고 생각한다.</li>
</ul>
<h3 id="객체-지향-프로그래밍oop이란-무엇인가" style="position:relative;"><a href="#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8Doop%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="객체 지향 프로그래밍oop이란 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>객체 지향 프로그래밍(OOP)이란 무엇인가</h3>
<ul>
<li>객체 지향 이전의 프로그래밍 패러다임을 살펴보면, 프로그래밍의 중심에는 컴퓨터가 있었다. 컴퓨터가 사고하는대로 프로그래밍을 하는 것이다.</li>
<li>이에 반해, 객체지향 프로그래밍은 인간 중심적 프로그래밍 패러다임이라고 할 수 있다.</li>
<li>OOP로 코드를 작성하면, 자주 사용되는 로직을 라이브러리로 만들어 계속 사용할 수 있으며, 이를 각종 예외상황에 맞게 처리해두면 그것을 재사용하는 개발자가 사소한 실수를 하더라도 에러를 컴파일 단계에서 잡아낼 수 있으므로 버그가 줄어들게 된다.</li>
<li>또한 이러한 라이브러리를 사용하는 사용자는 내부적으로 어떻게 동작하는지는 몰라도 제공하는 기능들을 편하게 사용할 수 있기 때문에 생상선이 높아지며</li>
<li>객체 단위로 코드가 나뉘어져 작성되기 때문에 디버깅이 쉽고 유지보수에 용이하다.</li>
<li>결론은 사람이 편하게 쓰기 위해 만들어진 것이 객체지향형 프로그래밍이다.</li>
<li>하지만 치명적인 단점으로는, 이렇게 만들어진 객체들은 상태를 갖게되어, 변수가 존재하게 되고 이를 통해 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킨다는 것이다. 이러한 이유로 함수형 패러다임이 주목받고 있다.</li>
<li>캡슐화 추상화 상속성 다형성</li>
</ul>
<h3 id="함수형-프로그래밍이란-무엇인가" style="position:relative;"><a href="#%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="함수형 프로그래밍이란 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>함수형 프로그래밍이란 무엇인가</h3>
<ul>
<li>사이드이펙트가 없는 순수 함수와 동작의 결과를 강조하는 프로그래밍 패러다임이다, 순수함수는 동일한 인자를 넣었을 때 동일한 출력값을 반환하므로 안정성과 생산성을 높일 수 있다.</li>
<li>객체지향프로그래밍과 비교하여 함수의 동작부가 간결해지기 때문에, 코드 이해도와 가독성에 큰 장점을 가지고 있다.</li>
<li>여기서 순수 함수란 동일한 입력값을 넣었을 때 항상 동일한 리턴값을 반환하며 외부에 영향을 받지 않는 함수이다.</li>
</ul>
<h3 id="api란-무엇인가" style="position:relative;"><a href="#api%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="api란 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>API란 무엇인가</h3>
<p><img src="https://user-images.githubusercontent.com/71132893/113861994-d365cf80-97e2-11eb-93fc-45e291cd08c2.png" alt="image"></p>
<ul>
<li>API(Appliaction Programming Interface)란 응용프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. 프로그램들이 서로 상호작용하는 것을 도와주는 매개체(다리)로 볼 수 있다.
<ol>
<li>API는 서버와 데이터베이스에 대한 출입구 역할을 한다.</li>
<li>API는 애플리케이션과 기기가 원활하게 통신할 수 있도록 한다.</li>
<li>API는 모든 접속을 표준화한다.</li>
</ol>
</li>
</ul>
<h4 id="restful-api란-무엇인가" style="position:relative;"><a href="#restful-api%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="restful api란 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RESTful API란 무엇인가</h4>
<ul>
<li>우선, 위키백과의 정의를 요약해보자면 다음과 같다.</li>
</ul>
<blockquote>
<p>월드 와이드 웹(World Wide Web a.k.a WWW)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반에 대한 패턴</p>
</blockquote>
<ul>
<li>REST란, REpresentational State Transfer 의 약자이다. 여기에 ~ful 이라는 형용사형 어미를 붙여 ~한 API 라는 표현으로 사용된다. 즉, REST 의 기본 원칙을 성실히 지킨 서비스 디자인은 'RESTful'하다라고 표현할 수 있다.</li>
<li>REST가 디자인 패턴이다, 아키텍처다 많은 이야기가 존재하는데, 하나의 아키텍처로 볼 수 있다. 좀 더 정확한 표현으로 말하자면, REST 는 Resource Oriented Architecture 이다. API 설계의 중심에 자원(Resource)이 있고 HTTP Method 를 통해 자원을 처리하도록 설계하는 것이다.</li>
<li>RESTful 하게 API 를 디자인 한다는 것은 무엇을 의미하는가.(요약)
<ol>
<li>리소스 와 행위 를 명시적이고 직관적으로 분리한다.
<ul>
<li>리소스는 URI로 표현되는데 리소스가 가리키는 것은 명사로 표현되어야 한다.</li>
<li>행위는 HTTP Method로 표현하고, GET(조회), POST(생성), PUT(기존 entity 전체 수정), PATCH(기존 entity 일부 수정), DELETE(삭제)을 분명한 목적으로 사용한다.</li>
</ul>
</li>
<li>Message 는 Header 와 Body 를 명확하게 분리해서 사용한다.
<ul>
<li>Entity 에 대한 내용은 body 에 담는다.</li>
<li>애플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API 버전 정보, 응답받고자 하는 MIME 타입 등은 header 에 담는다.</li>
<li>header 와 body 는 http header 와 http body 로 나눌 수도 있고, http body 에 들어가는 json 구조로 분리할 수도 있다.</li>
</ul>
</li>
<li>API 버전을 관리한다.
<ul>
<li>환경은 항상 변하기 때문에 API 의 signature 가 변경될 수도 있음에 유의하자.</li>
<li>특정 API 를 변경할 때는 반드시 하위호환성을 보장해야 한다.</li>
</ul>
</li>
<li>서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.
<ul>
<li>브라우저는 form-data 형식의 submit 으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 json 으로 보내든, 둘 다 form-data 형식으로 보내든 하나로 통일한다.</li>
<li>다른 말로 표현하자면 URI 가 플랫폼 중립적이어야 한다.</li>
</ul>
</li>
</ol>
</li>
<li>어떠한 장점이 존재하는가?
<ol>
<li>Open API 를 제공하기 쉽다</li>
<li>멀티플랫폼 지원 및 연동이 용이하다.</li>
<li>원하는 타입으로 데이터를 주고 받을 수 있다.</li>
<li>기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.</li>
</ol>
</li>
<li>단점은 뭐가 있을까?
<ol>
<li>사용할 수 있는 메소드가 4 가지 밖에 없다.</li>
<li>분산환경에는 부적합하다.</li>
<li>HTTP 통신 모델에 대해서만 지원한다.</li>
</ol>
</li>
</ul>
<h3 id="tdd란-무엇이며-어떠한-장점이-있는가" style="position:relative;"><a href="#tdd%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%9E%A5%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80" aria-label="tdd란 무엇이며 어떠한 장점이 있는가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TDD란 무엇이며 어떠한 장점이 있는가</h3>
<ul>
<li>
<p>TDD의 약자는 Test-Driven Development로, 직역하면 테스트 주도 개발로, 쉽게 말해 요구사항을 이행하여 코드를 짤 때, 테스트케이스를 먼저 만들고 테스트를 통과하기 위한 가장 간단한 코드를 작성하는 것을 말한다. 이를 반복하면서 제대로 동작하는지에 대한 피드백을 적극적으로 받는 것이다. 이후에 상황에 리팩토링을 하게되면, 말 그대로 테스트가 코드 작성을 주도하는 개발방식인 것이다.</p>
</li>
<li>
<p>좋은 코드를 작성하기란 정말 쉽지가 않다. 코드를 작성할 때 고려해야할 요소가 한 두가지가 아니기 때문이다. 코드량이 적을 때는 문제가 없지만, 코드를 확장해가면서 끊임없이 발견되는 버그들을 디버깅하는 과정에서 코드가 더렵혀지기 마련이다. 하지만 테스트 주도 개발을 해왔다면, 테스트 코드가 그 중심을 잡아 줄 수 있다. 뚱뚱한 함수를 여러 함수로 나누는 과정에서 해당 기능이 오작동을 일으킬 수도 있지만, 간단히 테스트를 돌려봄으로써 이에 대한 방지를 하고, 계속해서 리팩토링을 진행할 수 있게되는 것이다. 결과적으로 리팩토링 속도도 빨라지고, 코드의 퀄리티도 그만큼 향상되게 되는 것이다.</p>
</li>
<li>
<p>하지만 TDD에도 좋은 점만 있는 것은 아니다.</p>
<ul>
<li>첫 째로, 생산성에 문제가 생긴다.
<ul>
<li>두 배까지는 아니더라도 테스트코드가 필요하기 때문에, 코드량이 늘어난다. 코드 퀄리티보다는 빠른 생산성이 요구되는 시점에서 TDD는 큰 걸림돌이 될 수 있다.</li>
</ul>
</li>
<li>둘 째로, 작성이 쉽지는 않다는 것이다.
<ul>
<li>어떠한 부분을 테스트해야할지, 어떻게 테스트해야할지 등의 문제에 대해 학습이 필요하며 익숙해지는 데에도 시간이 걸린다. 진입 장벽이 존재한다는 것이다.</li>
</ul>
</li>
<li>셋 째로, 모든 상황에 대해서 테스트 코드를 작성할 수 있는가이다.
<ul>
<li>세상에는 다양한 사용자가 존재하며, 생각지도 못한 예외 케이스가 존재할 수 있다. 또한 만약 테스트를 반드시 해봐야 하는 부분에 있어서 테스트 코드를 작성하는 데 어려움이 발생한다면? 이러한 상황에서 주객이 전도되는 상황이 발생할 수 있다. 실제 코드가 테스트 코드보다 중심이 되어야 하는데, 테스트를 위해서 실제 코드의 구조를 바꿔야하는 경우의 고민이 생길 수도 있다는 것이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="mvc패턴이란-무엇인가" style="position:relative;"><a href="#mvc%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="mvc패턴이란 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MVC패턴이란 무엇인가</h3>
<ul>
<li>MVC패턴이란 디자인 패턴의 일종으로, M(Model), V(View), C(Controller)로 이루어져 있으며, 용도에 따라 역할을 확실하게 분리하여 유지보수를 용이하게 하며, 프로그램의 확장성과 유연성을 높이기 위한 기법이다.</li>
</ul>
<blockquote>
<p><strong>Model</strong> : 어플리케이션의 데이터, 자료를 의미한다.<br>
<strong>View</strong> : 사용자에게 보여지는 부분, 즉 유저 인터페이스(User interface)를 의미한다.<br>
<strong>Controller</strong> : Model과 View사이를 이어주는 브릿지(Bridge)역할을 의미한다.</p>
</blockquote>
<ul>
<li>여기서 디자인 패턴이란, 기존 환경 내에서 반복적으로 일어나는 문제들을 어떻게, 올바르고 빠르게, 풀어나갈 것인가에 대한 일종의 솔루션이다.</li>
<li>데이터가 추가되면 Model 부분만 수정하고, UI가 수정되면 View부분만 수정한다. Controller는 두 부분을 관장하기에 일부 수정이 필요하지만 기존처럼 무분별한 하드 코딩은 필요가 없다.</li>
<li>아래 그림은 MVC패턴의 기본적인 구조이다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/71132893/116238833-da0db400-a79c-11eb-836c-99fce27a7b7d.png" alt="image"></p>
<h4 id="model" style="position:relative;"><a href="#model" aria-label="model permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Model</h4>
<p>프로그램에 사용되는 데이터를 의미하며 데이터베이스(DB), 상수, 문자열과 같은 변수들, 비전 프로그램이라면 카메라 정보와 같은 것들이 해당된다.. 모델에는 뷰나 컨트롤러의 정보가 전혀 없다. 단지, 정보만 반환하거나 설정할 수 있다.</p>
<h4 id="view" style="position:relative;"><a href="#view" aria-label="view permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>View</h4>
<p>다이얼로그에 존재하는 텍스트박스, 라벨, 버튼 등 사용자 인터페이스(User interface) 요소들을 의미한다. 사용자가 제어하고 데이터를 확인할 수 있는 영역이다. 뷰에서는 별도의 데이터를 보관하지 않는다. 뷰에서 입력받고 출력해주는 모든 데이터는 모델을 사용해야한다.</p>
<h4 id="controller" style="position:relative;"><a href="#controller" aria-label="controller permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Controller</h4>
<p>모델과 뷰를 관장하는 브릿지(Bridge)역할을 수행한다. 사용자가 버튼을 클릭하면 이벤트는 뷰에서 발생하지만 내부 처리는 컨트롤러에서 관리하는 것이다. 또한, 입력이 발생하면 이에 대한 통지를 담당한다.</p>
<h3 id="git과-github은-무엇인가" style="position:relative;"><a href="#git%EA%B3%BC-github%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="git과 github은 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Git과 Github은 무엇인가</h3>
<ul>
<li>
<p>VCS의 일종이며, Linux에서 버전관리 소프트웨어의 내부 개발이 필요하다 판단되어 Linux개발자인 리누스 토발즈에 의해 만들어짐</p>
</li>
<li>
<p>깃은 다음의 목표를 갖고 개발되었음</p>
<ul>
<li>빠른 속도</li>
<li>단순한 구조</li>
<li>비선형적인 개발(수천 개의 동시 다발적인 브랜치)</li>
<li>완벽한 분산(DVCS)</li>
<li>Linux 커널같은 대형 프로젝트에도 유용할 것(속도나 데이터 크기 면에서)</li>
</ul>
</li>
<li>
<p>비선형적인 개발을 위해 브랜치 시스템을 도입하였고, 원격저장소와 로컬을 분리함으로써 여러 개발자가 분산작업을 원활하게 할 수 있게 고안되었다.</p>
</li>
<li>
<p>또한, 모든 커밋에 대해 Checksum(Hash)를 만들어 데이터 무결성을 보장한다.</p>
</li>
<li>
<p>GIT은 기본적으로 파일 시스템의 스냅샷을 저장한다.(커밋 당시의 GIT디렉토리의 모든 파일 정보를 저장) 또한, 파일 및 스냅샷을 해시하여 빠르게, 바뀐 버전인지 아닌지 체크한다.</p>
</li>
<li>
<p>이후 스냅샷들의 크기가 커지면 주기적으로 git gc(garbage collection)을 통해 delta를 만든다.</p>
</li>
</ul>
<p><a href="https://www.slideshare.net/ky200223/git-89251791">출처 : https://www.slideshare.net/ky200223/git-89251791</a></p>
<h4 id="gitflow-vs-github-flow-vs-gitlab-flow" style="position:relative;"><a href="#gitflow-vs-github-flow-vs-gitlab-flow" aria-label="gitflow vs github flow vs gitlab flow permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><a href="https://ujuc.github.io/2015/12/16/git-flow-github-flow-gitlab-flow/">Gitflow vs GitHub flow vs GitLab flow</a></h4>
<h4 id="오픈-소스-프로젝트에-컨트리뷰트하기" style="position:relative;"><a href="#%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8%ED%95%98%EA%B8%B0" aria-label="오픈 소스 프로젝트에 컨트리뷰트하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><a href="http://guruble.com/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%9D%98-%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%90%98%EB%8A%94-%EA%B2%83/">오픈 소스 프로젝트에 컨트리뷰트하기</a></h4>
<h2 id="1-2-자료구조" style="position:relative;"><a href="#1-2-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0" aria-label="1 2 자료구조 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1-2. 자료구조</h2>
<h3 id="array-vs-linked-list" style="position:relative;"><a href="#array-vs-linked-list" aria-label="array vs linked list permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array vs Linked List</h3>
<h4 id="array" style="position:relative;"><a href="#array" aria-label="array permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array</h4>
<ul>
<li>
<p>가장 기본적인 자료구조인 Array 자료구조는, 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 인덱스(index)로 해당 원소(element)에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 <code class="language-text">Big-O(1)</code>에 해당 원소로 접근할 수 있다. 즉 random access 가 가능하다는 장점이 있는 것이다.</p>
</li>
<li>
<p>하지만 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤(O(1)), 또 한 가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다. 만약 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다. 즉 빈 공간이 생기는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift해줘야 하는 비용(cost)이 발생하고 이 경우의 시간 복잡도는 <code class="language-text">O(n)</code>가 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 시간 복잡도 의 <code class="language-text">worst case</code> 는 <code class="language-text">O(n)</code>이 된다.</p>
</li>
<li>
<p>삽입의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1 씩 shift 해줘야 하므로 이 경우도 <code class="language-text">O(n)</code>의 시간을 요구하게 된다.</p>
</li>
</ul>
<h4 id="linked-list" style="position:relative;"><a href="#linked-list" aria-label="linked list permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Linked List</h4>
<ul>
<li>
<p>이 부분에 대한 문제점을 해결하기 위한 자료구조가 linked list 이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 <code class="language-text">O(1)</code> 만에 해결할 수 있는 것이다.</p>
</li>
<li>
<p>하지만 Linked List 역시 한 가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search 과정에 있어서 첫번째 원소부터 다 확인해봐야 한다는 것이다. Array 와는 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지이다. 이 과정 때문에, 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 <code class="language-text">O(n)</code>의 시간이 추가적으로 발생하게 된다.</p>
</li>
<li>
<p>결국 linked list 자료구조는 search 에도 <code class="language-text">O(n)</code>의 시간 복잡도 를 갖고, 삽입, 삭제에 대해서도 <code class="language-text">O(n)</code>의 시간 복잡도 를 갖는다. 그렇다고 해서 아주 쓸모없는 자료구조는 아니기에, 우리가 학습하는 것이다. 이 Linked List 는 Tree 구조의 근간이 되는 자료구조이며, Tree 에서 사용되었을 때 그 유용성이 드러난다.</p>
</li>
</ul>
<h3 id="stack-and-queue" style="position:relative;"><a href="#stack-and-queue" aria-label="stack and queue permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stack and Queue</h3>
<h4 id="stack" style="position:relative;"><a href="#stack" aria-label="stack permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stack</h4>
<p>선형 자료구조의 일종으로 <code class="language-text">Last In First Out(LIFO)</code>, 즉 나중에 들어간 원소가 먼저 나온다. 이것은 Stack의 가장 큰 특징이다. 차곡차곡 쌓이는 구조로 먼저 Stack에 들어가게 된 원소는 맨 바닥에 깔리게 된다. 그렇기 때문에 늦게 들어간 원소들은 그 위에 쌓이게 되고 호출 시에 가장 위에 있는 원소가 호출되는 구조이다.</p>
<h4 id="queue" style="position:relative;"><a href="#queue" aria-label="queue permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Queue</h4>
<p>선형 자료구조의 일종으로 <code class="language-text">First In First Out(FIFO)</code>, 즉 먼저 들어간 원소가 먼저 나온다. Stack과는 반대로 먼저 들어간 원소가 맨 앞에서 대기하고 있다가 먼저 나오게 되는 구조이다. 참고로 Java Collection에서 Queue는 인터페이스이다. 이를 구현하고 있는 Priority queue 등을 사용할 수 있다.</p>
<h3 id="tree" style="position:relative;"><a href="#tree" aria-label="tree permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tree</h3>
<ul>
<li>트리는 스택이나 큐와 같은 선형구조가 아닌 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다.</li>
<li>트리를 구성하고 있는 구성요소들(용어)
<ul>
<li><strong>Node(노드)</strong> : 트리를 구성하고 있는 각각의 요소를 의미한다.</li>
<li><strong>Edge(간선)</strong> : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.</li>
<li><strong>Root Node(루트 노드)</strong> : 트리 구조에서 최상위에 있는 노드를 의미한다.</li>
<li><strong>Terminal Node( = Leaf Node, 단말 노드)</strong> : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.</li>
<li><strong>Internal Node(내부노드, 비단말 노드)</strong> : 단말 노드를 제외한 모든 노드로, 루트 노드를 포함한다.</li>
</ul>
</li>
</ul>
<h4 id="binary-tree" style="position:relative;"><a href="#binary-tree" aria-label="binary tree permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Binary Tree</h4>
<ul>
<li>루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나뉘어진다. 또한 나뉘어진 두 서브 트리도 모두 이진 트리여야 한다. 또한, 공집합도 이진 트리로 포함시켜야 하는데, 그래야 재귀적으로 조건을 확인하며 단말노드에 다다랐을 때, 정의가 만족되기 때문이다. 자연스럽게 노드가 하나 뿐인 것도 이진 트리 정의에 만족하게 된다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/71132893/116415603-88d0f380-a874-11eb-9f8c-f836d5b6cee8.png" alt="image"><br>
<em><a href="https://winwoo.tistory.com/4">출처 : Winwoo's Story</a></em></p>
<ul>
<li>
<p>트리에서는 각 층별로 숫자를 매겨서 이를 트리의 Level(레벨)이라고 한다. 레벨의 값은 00부터 시작하고 따라서 루트 노드의 레벨은 0이다. 그리고 트리의 최고 레벨을 가리켜 해당 트리의 height(높이)라고 한다.</p>
</li>
<li>
<p>이진 트리에는 몇 가지 종류가 있는데, 이 중 몇 개를 살펴보자.</p>
<ul>
<li><strong>Perfect Binary Tree(포화 이진 트리)</strong> : 모든 레벨이 꽉 찬 이진 트리를 가리킨다.</li>
<li><strong>Complete Binary Tree(완전 이진 트리)</strong> : 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리킨다.</li>
<li><strong>Full Binary Tree(정 이진 트리)</strong> : 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리를 가리킨다.</li>
</ul>
</li>
<li>
<p>Binary Tree는 노드의 개수가 n개이고 root가 0이 아닌 1에서 시작할 때, i번째 노드에 대해서 parent(i) = i/2이며, left_child(i) = 2i이며, right_child(i) = 2i + 1의 index 값을 갖는다.</p>
</li>
</ul>
<h4 id="bstbinary-search-tree" style="position:relative;"><a href="#bstbinary-search-tree" aria-label="bstbinary search tree permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BST(Binary Search Tree)</h4>
<ul>
<li>
<p>효율적인 탐색을 위해서는 어떻게 찾을까만을 고민해서는 안된다. 거기에 더해서 효율적인 탐색을 위한 저장방법이 무엇일까를 고민해야한다. 이진 탐색 트리는 이진 트리의 일종으로, 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.</p>
<ul>
<li>규칙 1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.</li>
<li>규칙 2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.</li>
<li>규칙 3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.</li>
<li>규칙 4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.</li>
</ul>
</li>
<li>
<p>이진 탐색 트리의 연산은 <code class="language-text">O(log n)</code>의 시간 복잡도를 갖는다. 정확히 말하면 height(높이)를 사용하여, <code class="language-text">O(h)</code>라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가되기 때문이다. 하지만 이러한 이진 탐색 트리는 Skewed Tree(편향 트리)가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문이다. 이렬 경우 성능에 영향을 미치게 되며, <code class="language-text">O(n)</code>의 시간 복잡도를 가지며 탐색의 Worst Caser가 된다.</p>
</li>
<li>
<p>배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 Rebalancing기법이 등장하였다. 이는 균형을 잡기 위한 트리 구조의 재조정을 뜻하는데, 이 기법을 구현한 트리에는 여러가지 종류가 존재하며 그중 하나가 Red-Black Tree이다.</p>
</li>
</ul>
<h3 id="red-black-tree" style="position:relative;"><a href="#red-black-tree" aria-label="red black tree permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Red Black Tree</h3>
<p>RBT(Red Black Tree)는 BST(Binary Search Tree)를 기반으로 하는 트리 형식의 자료구조이다. 결론부터 말하자면, RBT에 데이터를 저장하게 되면, Search, Insert, Delete의 작업에 <code class="language-text">O(log n)</code>의 시간 복잡도가 소요된다. 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어이다. 동일한 노드의 개수일 때 depth가 최소가 되는 경우는 tree가 완전 이진 트리(Complete Binary Tree)인 경우이다.</p>
<h4 id="red-black-tree의-정의" style="position:relative;"><a href="#red-black-tree%EC%9D%98-%EC%A0%95%EC%9D%98" aria-label="red black tree의 정의 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Red Black Tree의 정의</h4>
<p>RBT는 다음의 성질을 만족하는 BST이다.</p>
<ol>
<li>각 노드는 <code class="language-text">red</code> or <code class="language-text">black</code>이라는 색깔을 갖는다.</li>
<li>Root Node의 색깔은 <code class="language-text">black</code>이다.</li>
<li>각 leaf Node는 <code class="language-text">black</code>이다.</li>
<li>어떤 노드의 색깔이 <code class="language-text">red</code>라면 두 개의 children의 색깔은 모두 <code class="language-text">black</code>이다.</li>
<li>각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 black nodes 들을 포함하고 있다. 이를 해당 노드의 <code class="language-text">Black-Height</code>라고 한다.<br>
<em>cf) <code class="language-text">Black-Height</code> : 노드x로부터 노드x를 포함하지 않은 leaf node까지의 siple path 상에 있는 black nodes의 개수</em></li>
</ol>
<h4 id="red-black-tree의-특징" style="position:relative;"><a href="#red-black-tree%EC%9D%98-%ED%8A%B9%EC%A7%95" aria-label="red black tree의 특징 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Red Black Tree의 특징</h4>
<ol>
<li>BST이므로, BST의 특징을 모두 갖는다.</li>
<li>Root node부터 leaf node 까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 <code class="language-text">balanced</code> 상태라고 한다.</li>
<li>노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을저장한다. 이러한 NIL 들을 leaf node로 간주한다.</li>
</ol>
<p><em>RBT는 BST의 삽입, 삭제 연산 과정에사 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조이다. 이를 어떻게 해결할 것인가?</em></p>
<h4 id="삽입" style="position:relative;"><a href="#%EC%82%BD%EC%9E%85" aria-label="삽입 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>삽입</h4>
<p>우선 BST의 특성을 유지하면서 노드를 삽입한다. 삽입된 노드의 색깔을 <code class="language-text">Red</code>로 지정한다.<code class="language-text">Red</code>로 지정하는 이유는 Black-Height 변경을 최소화 하기 위함이다. 삽입 결과, RBT의 특성에 위배(violation)될 경우, 노드의 색깔을 조정하고, Black-Height가 위배되었다면 rotation을 통해 height를 조정한다. 이러한 과정을 통해 RBT의 동일한 height에 존재하는 internal node들의 Black-height가 같아지게되고 최소 경로와 최대 경로의 크기 비율이 2 미만으로 유지된다.</p>
<h4 id="삭제" style="position:relative;"><a href="#%EC%82%AD%EC%A0%9C" aria-label="삭제 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>삭제</h4>
<p>삭제도 삽입과 마찬가지로 BST의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 child의 개수에 따라 rotation 방법이 달라지게 된다. 만약 지워진 노드의 색깔이 <code class="language-text">Black</code>이라면 Black-Height가 1 감소한 경로에 black node가 1개 추가되도록 rotation하고, 노드의 색깔을 조정한다. 지워진 노드의 색깔이 <code class="language-text">Red</code>라면 violation이 발생하지 않으므로 RBT가 그대로 유지된다.</p>
<blockquote>
<p><em>Java Colletion에서 ArrayList도 내부적으로 RBT로 이루어져 있고, HashMap에서의 <code class="language-text">Separate Chaining</code>에서도 사용된다. 그만큼 효율이 좋고 중요한 자료구조이다.</em></p>
</blockquote>
<h3 id="binary-heap" style="position:relative;"><a href="#binary-heap" aria-label="binary heap permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Binary Heap</h3>
<ul>
<li>
<p>자료구조의 일종으로 Tree의 형식을 하고 있으며 그 중에서도 배열에 기반한 <code class="language-text">Complete Binary Tree</code>의 형식을 하고 있다. 배열에 트리의 값들을 넣어줄 때, 0번째는 건너뛰고 1번 index부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다. <code class="language-text">힙(Heap)</code>에는 <code class="language-text">최대 힙(max heap)</code>, <code class="language-text">최소 힙(min heap)</code> 두 가지 종류가 있다.</p>
</li>
<li>
<p><code class="language-text">Max Heap</code>이란, 각 노드의 값이 해당 childern의 값도가 크거나 같은 <code class="language-text">Complete Binary Tree</code>를 말한다.(Min Heap은 그 반대이다.)</p>
</li>
<li>
<p><code class="language-text">Max Heap</code>에서는 Root node에 있는 값이 제일 크므로, 최댓값을 찾는데 쇼오되는 연산의 시간 복잡도가 O(1)이다. 그리고 <code class="language-text">Complete Binary Tree</code>이기 때문에, 배열을 사용하여 효율적으로 관리할 수 있다(즉, random access가 가능한다. Min heap에서는 최솟값을 찾는데 소요되는 연산의 시간 복잡도가 O(1)이다.). 하지만 heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify과정을 거쳐 heap 구조를 유지한다. 이러한 경우에는 결국 O(log n)의 시간복잡도로 최댓값 또는 최솟값에 근접할 수 있게 된다.</p>
</li>
</ul>
<h3 id="hash-table" style="position:relative;"><a href="#hash-table" aria-label="hash table permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hash Table</h3>
<ul>
<li>
<p><code class="language-text">hash</code>는 내부적으로 <code class="language-text">배열</code>을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 특정한 값을 search 하는 데에 있어, 데이터 고유의 <code class="language-text">인덱스</code>로 접근하게 되므로 average case에 대해서 시간복잡도는 O(1)이 되는 것이다. 항상 O(1)이 아닌, average case에 대해서만 O(1)인 것은 <code class="language-text">collision(해시충돌)</code> 때문이다. 하지만 문제는 이 인덱스로 저장되는 <code class="language-text">key</code>의 값이 불규칙하다는 것이다.</p>
</li>
<li>
<p>그래서 특별한 알고리즘을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 연산에서 추가적인 비용이 없도록 만들어진 구조이다.</p>
</li>
</ul>
<h4 id="hash-function" style="position:relative;"><a href="#hash-function" aria-label="hash function permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hash Function</h4>
<ul>
<li>
<p>위에서 말한 <code class="language-text">특별한 알고리즘</code>이란 것을 통해 고유한 인덱스 값을 설정하는 것이 중요해보인다. 위에서 언급한 <code class="language-text">특별한 알고리즘</code>을 <code class="language-text">hash method</code> 혹은 <code class="language-text">해시 함수(hash function)</code>이라고 하며, 이 메소드에 의해 반환된 데이터 고유 숫자 값을 <code class="language-text">hashcode</code>라고 한다. 저장되는 값들의 key 값을 <code class="language-text">hash function</code>을 통해서 작은 범위의 값들로 바꿔준다.</p>
</li>
<li>
<p>하지만 어설픈 <code class="language-text">hash function</code>을 통해서 key 값들을 결정한다면 동일한 값이 도출될 수가 있다. 이렇게 되면 동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것인데, 이를 <code class="language-text">collision</code>이라고 한다.<br>
<em><strong>Collsion</strong> : 서로 다른 두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산되는 행위)되는 것으로, 이것이 발생하면 같은 곳에 저장할 수 없게 된다.</em></p>
</li>
<li>
<p>그렇다면 좋은 <code class="language-text">hash function</code>은 어떠한 조건들을 갖추고 있어야 할까?</p>
</li>
<li>
<p>일반적으로 좋은 <code class="language-text">hash function</code>은 키의 일부분을 참조하여 해쉬 값을 만들지 않고 키 전체를 참조하여 해쉬 값을 만들어 낸다. 하지만 좋은 해쉬 함수는 키가 어떤 특성을 가지고 있느냐에 따라 달라지게 된다.</p>
</li>
<li>
<p><code class="language-text">hash function</code>을 무조건 1 : 1로 만드는 것보다 <code class="language-text">Collision</code>을 최소화하는 방향으로 설계하고 발생하는 <code class="language-text">Collision</code>에 대비해 어떻게 대응할 것인가가 더 중요하다. 1 : 1 대응이 되도록 만드는 것이 거의 불가능하기도 하지만 그런 <code class="language-text">hash function</code>을 만들어봤자 그건 array와 다를 바 없고 메모리를 너무 차지하게 된다.</p>
</li>
<li>
<p><code class="language-text">Collision</code>이 많아질수록 Search에 필요함 시간복잡도가 O(1)에서 O(n)에 가까워진다. 어설픈 <code class="language-text">hash function</code>은 hash를 hash답게 사용하지 못하도록 한다. 좋은 <code class="language-text">hash function</code>을 선택하는 것은 hash table의 성능 향상에 필수적인 것이다.</p>
</li>
<li>
<p>따라서 hashing된 인덱스에 이미 다른 값이 들어 있다면 새 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수이며, 그 방법들에 대해 알아보자.</p>
</li>
</ul>
<h4 id="resolve-collision" style="position:relative;"><a href="#resolve-collision" aria-label="resolve collision permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resolve Collision</h4>
<p>기본적인 두 가지 방법부터 알아보자. 해시 충돌을 해결하기 위한 다양한 자료가 있지만, 다음 두 가지 방법을 기초로, 응용한 방법들이기 때문이다.</p>
<h5>Open Addressing 방식 (개방 주소법)</h5>
<ul>
<li>
<p><code class="language-text">Collision</code>이 발생하면(삽입하려는 해시 버킷이 이미 사용중인 경우라면), <strong>다른 해시 버킷에 해당 자료를 삽입</strong>하는 방식이다. 버킷이란 바구니와 같은 개념으로, 데이터를 저장하기 위한 공간이라고 생각하면 된다. 다른 해시 버킷이란 어떤 해시 버킷을 말하는 것인가.</p>
</li>
<li>
<p>공개 주소 방식이라고도 불리는 이 알고리즘은 <code class="language-text">Collision</code>이 발생하면 데이터를 저장할 장소를 찾아 다닌다. Worst Case의 경우 비어잇는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 이 과정에서도 다음과 같은 방법들이 존재한다.</p>
<ol>
<li><strong>Linear Probing</strong> : 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행한다.</li>
<li><strong>Quadratic probing</strong> : 2차 함수를 이용해 탐색할 위치를 찾는다.</li>
<li><strong>Double hashing probing</strong> : 하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당한다. 위 두 가지 방법에 비해 많은 연산량이 요구된다.</li>
</ol>
</li>
</ul>
<h5>Separate Chaining 방식 (분리 연결법)</h5>
<ul>
<li>일반적으로 Open Addressing은 Separate Chaining보다 느리다. Open Addressing의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면 Separate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정할 수 있다면 Worst Case에 가까워 지는 빈도를 줄일 수 있다. Java7에서는 Separate Chaining 방식을 사용하여 HashMap을 구현하고 있다. Separate Chaining 방식으로는 두 가지 구현 방식이 존재한다.
<ul>
<li>
<p><strong>연결 리스트를 사용하는 방식(Linked List)</strong> : 각각의 버킷(bucket)들을 연결리스트(Linked List)로 만든 후, Collision이 발생하면 해당 버킷의 list에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다. 또 다른 특징으로는, 버킷을 계속해서 사용하는 Open Address 방식에 비해 테이블의 확장을 늦출 수 있다.</p>
</li>
<li>
<p><strong>Tree를 사용하는 방식(Red-Black Tree)</strong> : 기본적인 알고리즘은 Separate Chaining 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할단된 key-value 쌍의 개수이다. 데이터의 개수가 적다면 연결리스트를 사용하는 것이 맞는데, 트리는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 Worst case를 살펴보면, 트리와 연결 리스트의 성능 상 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 연결리스트를 사용한다.</p>
</li>
</ul>
</li>
</ul>
<h6>데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?</h6>
<p>앞서 말했듯, 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 이 key-value쌍의 개수가 6개와 8개를 기준으로 결정한다. 기준이 두 개인 것이 이상하게 느껴질 수 있으나, 이는 변경하는 데 소요되는 비용을 줄이기 위함이다. 6개이하 일 때 연결리스트로, 8개이상일 때 트리를 사용하는 식이다.</p>
<h6>한 가지 상황을 가정해보자.</h6>
<p>해시 버킷에 6개의 key-value 쌍이 들어있었다. 그리고 하나의 값이 추가되었다. 만약 기준이 6과 7이라면 자료구조를 연결리스트에서 트리로 변경해야 한다. 그러다가 하나의 값이 삭제된다면 다시 트리에서 연결 리스트로 자료구조를 변경해야한다. 각각 자료구조로 넘어가는 기준의 차이가 1이라면 switching 비용이 너무 많이 필요하게 되는 것이다. 그래서 2라는 여유를 남겨두고 기준을 잡아준 것이다. 따라서 데이터의 개수가 6개에서 7개로 증가했을 때는 연결리스트의 자료구조를 취하고 있을 것이고 8개에서 7개로 감소했을 때는 트리의 자료구조를 취하고 있을 것이다.</p>
<h5>Open Adderessing vs Separate Chaining</h5>
<p>일단 두 방식 모두 Worst Case에서 시간 복잡도는 O(M)이다. 하지만 Open Adderessing 방식은 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining에 비해 캐시 효율이 더 높다. 따라서 데이터의 개수가 충분히 적다면 Open Addressing 방식이 Separate Chaining보다 더 성능이 좋다. 또한, Separate Chaining 방식에 비해 Open Addressing 방식은 버킷을 계속해서 사용하기 때문에, Separate Chaining 방식은 테이블의 확장을 보다, 늦출 수 있게 된다.</p>
<h5>보조 해시 함수(Supplement Hash Function)</h5>
<p>보조 해시 함수(Supplement Hash Function)의 목적은 key의 해시 값을 변형하여 해시 충돌 가능성을 줄이는 것이다. Separate Chaining 방식을 사용할 때 함께 사용되며, 보조 해시 함수를 이용해 Worst Case에 가까워지는 경우를 줄일 수 있다.</p>
<h4 id="해시-버킷-동적-확장resize" style="position:relative;"><a href="#%ED%95%B4%EC%8B%9C-%EB%B2%84%ED%82%B7-%EB%8F%99%EC%A0%81-%ED%99%95%EC%9E%A5resize" aria-label="해시 버킷 동적 확장resize permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>해시 버킷 동적 확장(Resize)</h4>
<p>해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만, 해시 충돌로 인해 성능 상의 손실이 발생한다. 그래서 HashMap은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면, 해시 버킷의 개수를 두 배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다. 위에서 언급한 '일정개수 이상'이라는 것은, 해시 버킷 크기를 두 배로 확장하는 임계점으로, 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때를 가리킨다. 여기서, 0.75라는 수는 <code class="language-text">load factor</code>이라고 불린다.</p>
<h3 id="graph" style="position:relative;"><a href="#graph" aria-label="graph permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Graph</h3>
<h4 id="정점과-간선의-집합-graph" style="position:relative;"><a href="#%EC%A0%95%EC%A0%90%EA%B3%BC-%EA%B0%84%EC%84%A0%EC%9D%98-%EC%A7%91%ED%95%A9-graph" aria-label="정점과 간선의 집합 graph permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정점과 간선의 집합, Graph</h4>
<p>cf) 트리 또한 그래프이며, 그 중에서 사이클이 허용되지 않는 그래프를 말한다.</p>
<h4 id="graph-관련-용어정리" style="position:relative;"><a href="#graph-%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC" aria-label="graph 관련 용어정리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Graph 관련 용어정리</h4>
<h5>Undirected Graph와 Directed Graph(Digraph)</h5>
<p>말 그대로 정점과 간선의 연결관계에 있어서 방향성이 없는 그래프를 Undirected Graph라 하고, 간선에 방향성이 포함되어 있는 그래프를 Directed Graph라고 한다.</p>
<ul>
<li>Directed Graph(Digraph)</li>
</ul>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token constant">V</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span>
<span class="token constant">E</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">=</span> vertex u에서 vertex v로 가는 edge</code></pre></div>
<ul>
<li>Undirected Graph</li>
</ul>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token constant">V</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span>
<span class="token constant">E</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">=</span> vertex u와 vertex v를 연결하는 edge</code></pre></div>
<h5>Degree</h5>
<p>Undirected Graph에서 각 정점(Vertex)에 연결된 간선(edge)의 개수를 Degree라고 한다. Directed Graph에서는 간선에 방향성이 존재하기 때문에, Degree가 두 개로 나뉜다. 각 정점으로부터 나가는 간선의 개수를 OutDegree, 들어오는 간선의 개수를 Indegree라고 한다.</p>
<h5>가중치 그래프(Weight Graph)와 부분 그래프(Sub Graph)</h5>
<p>가중치 그래프란 간선에 가중치 정보를 두어서 구성한 그래프를 말한다. 반대의 개념인 비가중치 그래프, 즉 모든 간선의 가중치가 동일한 그래프도 물론 존재한다.<br>
부분 그래프는 부분 집합과 유사한 개념으로, 본래 그래프의 일부 정점 및 간선으로 이루어진 그래프를 말한다.</p>
<h4 id="graph-구현-방법" style="position:relative;"><a href="#graph-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95" aria-label="graph 구현 방법 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Graph 구현 방법</h4>
<h5>인접 행렬(Adjacent matrix) : 정방 행렬을 사용하는 방법</h5>
<p>해당하는 위치의 value를 통해서 정점 간의 연결 관계를 O(1)로 파악할 수 있다. edge의 개수와는 무관하게 V<sup>2</sup>의 공간 복잡도를 갖는다. Dense Graph를 표현할 때 적절한 방법이다.</p>
<h5>인접 리스트(Adjacent list) : 연결 리스트를 사용하는 방법</h5>
<p>정점의 adjacent list를 확인해봐야 하므로, 정점간에 연결이 되어 있는지 확인하는 데에 오래 걸린다. 공간 복잡도는 O(E + V)이다. Sparse Graph를 표현하는 데에 적절한 방법이다.</p>
<h4 id="graph-탐색" style="position:relative;"><a href="#graph-%ED%83%90%EC%83%89" aria-label="graph 탐색 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Graph 탐색</h4>
<p>그래프는 정점의 구성뿐만 아니라, 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.</p>
<h5>깊이 우선 탐색(Depth First Searchs : DFS)</h5>
<p>그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아간다라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더이상 연결되지 않은 정점이 없으면 바로 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다. 구현하는 데에는 Stack을 사용한다. 시간 복잡도는 O(V + E) = vertext개수 + edge개수</p>
<h5>너비 우선 탐색(Breadth First Searchs : BFS)</h5>
<p>그래프 상에 존재하는 임이의 한 정점으로부터 연결되어 있는모든 정점으로 나아간다. Tree에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS에서는 자료구조를 Queue를 사용한다. 연락을 취할 정점의 순서를 기록하기 위한 것이다. 우선, 탐색을 시작하는 정점을 Queue에 넣는다(enqueue). 그리고 dequeue하면서 dequeue하는 정점과 간선으로 연결되어 있는 정점들은 enqueue한다. 즉, 정점들을 방문한 순서대로 queue에 저장하는 방법을 사용하는 것이다. 시간 복잡도는 O(V + E) = vertext개수 + edge개수<br>
<em>cf) BFS로 구한 경로는 최단 경로이다</em></p>
<h4 id="minimum-spanning-tree" style="position:relative;"><a href="#minimum-spanning-tree" aria-label="minimum spanning tree permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Minimum Spanning Tree</h4>
<p>그래프 G의 spanning tree 중 edge weight의 합이 최소인 spanning tree를 말한다. 여기서 말하는 spanning tree란, 그래프 G의 모든 정점이 cycle이 없이 연결된 형태를 말한다.</p>
<h5>Kruskal algorithm</h5>
<ul>
<li>
<p>초기화 작업으로 간선 없이 정점들만으로 그래프를 구성한다. 그리고 weight이 제일 작은 간선부터 검토한다. 그러기 위해선 edge set을 non-decreasing으로 sorting해야 한다. 그리고 가장 작은 weight에 해당되는 간선을 추가할 때 그래프에 cycle이 생기지 않는 경우에만 추가한다. spanning tree가 완성되면, 모든 정점들이 연결된 상태로 종료가 되고, 완성될 수 없는 그래프에 대해서는 모든 간선에 대해서 판단이 이루어지면 종료된다.</p>
</li>
<li>
<p>cycle 생성여부를 판단하는 순서</p>
<ol>
<li>Graph의 각 정점에 <code class="language-text">set-id</code>라는 것을 추가적으로 부여한다.</li>
<li>초기화 과정에서 모두 1 ~ n 까지의 값으로 각각의 정점들을 초기화한다.</li>
<li>여기서 0은 어떠한 간선과도 연결되지 않았음을 의미한다.</li>
<li>연결할 때마다 <code class="language-text">set-id</code>를 하나로 통일시키는데, 값이 동일한 <code class="language-text">set-id</code>개수가 많은 <code class="language-text">set-id</code>값으로 통일 시킨다.</li>
</ol>
</li>
<li>
<p>시간복잡도</p>
<ol>
<li>Edge의 weight를 기준으로 sorting할 경우 : O(E log E)</li>
<li>cycle 생성 여부를 검사하고 set-id를 통일 : O(E + V log V) => 전체 시간 복잡도 : O(E log E)</li>
</ol>
</li>
</ul>
<h5>Prim algorithm</h5>
<ul>
<li>
<p>초기화 과정에서 한 개의 정점으로 이루어진 초기 그래프 A를 구성한다. 그 후, 그래프 A 내부에 있는 정점으로부터 외부에 있는 정점 사이의 간선을 연결하는데, 그 중 가장 작은 weight의 간선을 통해 연결되는 정점을 추가한다. 어떤 정점이건 상관없이 edge의 weight를 기준으로 연결하는 것이다. 이렇게 연결된 정점은 그래프 A에 포함된다. 위 과정을 반복하고 모든 정점들이 연결되면 종료된다.</p>
</li>
<li>
<p>시간 복잡도 : O(E log V)</p>
</li>
</ul>
<h2 id="1-3-네트워크" style="position:relative;"><a href="#1-3-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" aria-label="1 3 네트워크 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1-3. 네트워크</h2>
<h3 id="http의-get과-post-비교" style="position:relative;"><a href="#http%EC%9D%98-get%EA%B3%BC-post-%EB%B9%84%EA%B5%90" aria-label="http의 get과 post 비교 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP의 GET과 POST 비교</h3>
<p>공통점은 GET과 POST 모두, HTTP 프로토콜을 이용하여 서버에 무엇인가를 요청할 때 사용하는 방식이다. 하지만 둘의 특징을 제대로 이해하여, 기술의 목적에 알맞은 용도로 사용해야 한다.</p>
<h4 id="get" style="position:relative;"><a href="#get" aria-label="get permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GET</h4>
<p>우선 GET 방식은, 요청하는 데이터가 HTTP Request Message의 Header 부분에 url이 담겨서 전송된다. 때문에 url 의 <code class="language-text">?</code> 뒤에 데이터가 붙어 request를 보내게 되는 것이다. 이러한 방식은 url이라는 공간에 담겨서 가기 때문에, 전송할 수 있는 데이터의 크기가 제한적이다. 또한, 보안이 필요한 데이터에 대해서는 데이터가 그대로 url에 노출되므로 <code class="language-text">GET</code>방식은 적절하지 않다(e.g. password)</p>
<h4 id="post" style="position:relative;"><a href="#post" aria-label="post permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>POST</h4>
<p>POST 방식의 request는 HTTP Request Message의 Body 부분에 데이터가 담겨서 전송된다. 때문에, 바이너리 데이터를 요청하는 경우에는 POST 방식으로 보내야하는데, 이는 POST의 데이터 크기가 GET방식보다 크고 보안면에서 낫기 때문이다(하지만 보안적인 측면에서는 암호화를 하지 않는 이상 비슷하다.).</p>
<h4 id="비교" style="position:relative;"><a href="#%EB%B9%84%EA%B5%90" aria-label="비교 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>비교</h4>
<ul>
<li>
<p>우선 GET은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여주기만 하는 용도인 것이지, 서버의 값이나 상태 등을 변경하지 않는 SELECT적인 성향을 갖고있다. 반면에 POST는 서버의 값이나 상태를 변경하거나 혹은 추가하기 위해서 사용되는 것이다.</p>
</li>
<li>
<p>부수적인 차이점을 좀 더 살펴보자면 GET방식의 요청은 브라우저에 Caching할 수 있다. 때문에 POST 방식으로 요청해야만하는 것을, 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET방식으로 요청한다면 기존에 Caching되었던 데이터가 응당해 문제가 될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용하는 것이 중요하다.<br>
<em>Caching : 기본적으로는 저장한다는 뜻이다. 오랜시간이 걸리는 작업의 결과를 저장해서, 차후에 사용할 때를 대비해 시간과 비용을 필요를 회피하는 기법이다.</em></p>
</li>
</ul>
<h3 id="http와-https" style="position:relative;"><a href="#http%EC%99%80-https" aria-label="http와 https permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP와 HTTPS</h3>
<h4 id="http의-문제점" style="position:relative;"><a href="#http%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90" aria-label="http의 문제점 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP의 문제점</h4>
<ul>
<li>HTTP는 평문 통신이기 때문에 도청이 가능하다.</li>
<li>통신 상대를 확인하지 않기 때문에 위장이 가능하다.</li>
<li>완전성을 증명할 수 없기 때문에 변고가 가능하다.</li>
</ul>
<p><em>위 세가지는 다른 암호화 하지 않은 프로토콜에도 공통되는 문제점이다</em></p>
<h5>TCP/IP는 도청이 가능한 네트워크이다.</h5>
<p>TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에, 암호화하여 통신해야 한다.</p>
<h6>보안 방법</h6>
<ol>
<li>통신 자체를 암호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다. SSL을 조합한 HTTP를 HTTPS(HTTP secure) or HTTP over SSL이라고 부른다.</li>
<li>콘텐츠를 암호화한다. 말 그대로, HTTP를 사용해서 운반하는 내용인 HTTP 메시지안에, 포함되는 콘텐츠만을 암호화하는 것이다. 암호화해서 전송하면 메시지를 받는 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.</li>
</ol>
<h5>통신 상대를 확인하지 않기 때문에 위장이 가능하다.</h5>
<p>HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 리퀘스트를 보낼 수 있다. IP 주소나 포트 등에서 그 웹 서버에 액세스 제한이 없는 경우, 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다. 이러한 특징은 여러 문제점을 유발한다.</p>
<ol>
<li>리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야하는 웹 서버인지 확인할 수 없다.</li>
<li>리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지 확인할 수 없다.</li>
<li>통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다.</li>
<li>어디에서 누가 리퀘스트를 했는지 확인할 수 없다.</li>
<li>의미없는 리퀘스트도 수신하게 된다. -> DoS 공격을 방지할 수 없다.</li>
</ol>
<h6>보안 방법</h6>
<p>위 암호화 방법으로 언급된 SSL로 상대를 확인할 수 있다. SSL은 상대를 확인하는 수단으로 <strong>증명서</strong>를 제공하고 있다. 증명서는 신뢰할 수 있는 <strong>제 3기관에 의해 발행</strong>되는 것이기 때문에 서버나 클라이언트가 실재한다는 사실을 증명한다. 이 증명서를 이용함으로써 내가 누구와 통신하고 있는지, 통신 상대를 구별할 수 있고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 또한, 클라이언트는 이 증명서로 본인 확인을 하고 웹사이트 인증에서도 이용할 수 있다.</p>
<h5>완전성을 증명할 수 없기 때문에 변조가 가능하다.</h5>
<p>여기서 완전성이란, 정보의 정확성을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수가 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에, 누군가에 의해 정보가 변조되더라도 이 사실을 알 수가 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle)이라고 부른다.</p>
<h6>보완 방법</h6>
<p>MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법도 존재하지만, 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 HTTPS를 사용해야 한다. SSL에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.</p>
<h4 id="https" style="position:relative;"><a href="#https" aria-label="https permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTPS</h4>
<ul>
<li>
<p>HTTPS는 SSL의 껍질을 덮어쓴 HTTP라고 할 수 있다. 즉, HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니라는 것이다. HTTP 통신하는 소켓 부분을 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 프로토콜로 대체하는 것뿐이다. HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게 된다. SSL을 사용한 HTTPS는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.</p>
</li>
<li>
<p>HTTPS의 SSL에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호화 시스템을 사용한다. 공통키를 공개키 암호화 방식으로 교환한 다음에, 다음부터의 통신은 공통키 암호를 사용하는 방식이다.</p>
</li>
</ul>
<h5>모든 웹 페이지에서 HTTPS를 사용해도 될까?</h5>
<ul>
<li>
<p>평문 통신에 비해서 암호화 통신은 CPU나 메모리 등의 리소스를 더 많이 요구한다. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어들게 된다.</p>
</li>
<li>
<p>하지만 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 작동한다. 따라서 과거의 웹은 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용하는 방식이었다면, 현재는 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있다.</p>
</li>
</ul>
<h3 id="tcp와-udp" style="position:relative;"><a href="#tcp%EC%99%80-udp" aria-label="tcp와 udp permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP와 UDP</h3>
<h4 id="udpuser-datagram-protocol-사용자-데이터그램-프로토콜" style="position:relative;"><a href="#udpuser-datagram-protocol-%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C" aria-label="udpuser datagram protocol 사용자 데이터그램 프로토콜 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)</h4>
<ul>
<li>
<p>UDP는 <strong>비연결형 프로토콜</strong>이다. IP데이터그램을 캡슐화하여 보내는 방법과, 연결 설정을 하지 않고 보내는 방법을 제공한다. UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 <strong>재전송을 하지 않는다</strong>. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP프로토콜에 인터페이스를 제공하는 것이다.</p>
</li>
<li>
<p>종종 클라이언트는 서버로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면 클라이언트는 time out되고, 응답을 다시 시도할 수 있으면 된다. 코드가 간단할 뿐만 아니라 TCP처럼 초기설정(initial setup)에서 요구되는 프로토콜 보다 적은 메시지가 요구된다.</p>
</li>
<li>
<p>UDP를 사용한 것들에는 DNS가 있다. 어떤 호스트 네임의 IP주소를 찾을 필요가 있는 프로그램은, DNS서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP주소를 포함한 UDP패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제 또한 필요하지 않다.</p>
</li>
</ul>
<h4 id="tcptransmission-control-protocol-전송-제어-프로토콜" style="position:relative;"><a href="#tcptransmission-control-protocol-%EC%A0%84%EC%86%A1-%EC%A0%9C%EC%96%B4-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C" aria-label="tcptransmission control protocol 전송 제어 프로토콜 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP(Transmission Control Protocol, 전송 제어 프로토콜)</h4>
<ul>
<li>
<p>대부분의 인터넷 응용 분야들은 신뢰성과 순차적인 전달을 필요로 한다. UDP로는 이를 만족시킬 수 없기 때문에, 탄생한 것이 TCP이다. TCP는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성이 있는 바이트 스트림을 전송하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. TCP에서 연결성립(connection establishment)는 3-way handshake를 통해 행해진다.</p>
</li>
<li>
<p>모든 TCP 연결은 전이중(Full-duplex), 점대점(point-to-point)방식이다. 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며, 점대점이란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미한다. TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.</p>
</li>
</ul>
<h3 id="3-way-handshake" style="position:relative;"><a href="#3-way-handshake" aria-label="3 way handshake permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3-way-handshake</h3>
<p>3-way-handshake란, TCP에서 연결 성립(connection establishment)을 시킬 때 사용되는 기법이다.</p>
<p><img src="https://user-images.githubusercontent.com/71132893/116960525-986c9400-acdb-11eb-91f6-118897d140e8.png" alt="image"></p>
<ol>
<li>클라이언트는 서버에 접속을 요청하는 <strong>SYN(a)</strong> 패킷을 보낸다.</li>
<li>서버는 클라이언트의 요청인 <strong>SYN(a)</strong> 를 받고, 클라이언트에게 요청을 수락한다는 <strong>ACK(a + 1)</strong> 과 <strong>SYN(b)</strong> 가 설정된 패킷을 보낸다.</li>
<li>클라이언트는 서버의 수락 응답인 <strong>ACK(a + 1)</strong> 와 <strong>SYN(b)</strong> 패킷을 받고, <strong>ACK(b + 1)</strong> 을 서버로 보내면 연결이 <strong>성립(establishment)</strong> 된다.</li>
</ol>
<p><em>SYN : SYNchronize sequence number</em><br>
<em>ACK : ACKnowledgement</em></p>
<h4 id="왜-3-way인가-2-way로는-충분하지-않은가" style="position:relative;"><a href="#%EC%99%9C-3-way%EC%9D%B8%EA%B0%80-2-way%EB%A1%9C%EB%8A%94-%EC%B6%A9%EB%B6%84%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80%EA%B0%80" aria-label="왜 3 way인가 2 way로는 충분하지 않은가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>왜 3-way인가? 2-way로는 충분하지 않은가?</h4>
<p>비유를 들어보자, 일단 클라이언트가 자신의 목소리가 들리는지 물어본다(SYN(a)). 서버는 클라이언트의 목소리가 들린다고 말한다(ACK(a + 1)). 그리고 자신의 목소리가 들리는지 물어본다(SYN(b)). 클라이언트는 서버의 목소리가 들린다고 말한다(ACK(b + 1)). 이런 과정인 셈이다. TCP connection은 양방향성 connection이다. 클라이언트에서 서버에게 존재를 알리고 패킷을 보낼 수 있다는 것을 알리듯, 서버에서도 클라이언트에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야한다. 그렇기 때문에 2-way-handshake로는 부족하다.</p>
<p><a href="https://asfirstalways.tistory.com/356">3-way-handshake 출처 : https://asfirstalways.tistory.com/356</a></p>
<h3 id="dns-round-robin-방식" style="position:relative;"><a href="#dns-round-robin-%EB%B0%A9%EC%8B%9D" aria-label="dns round robin 방식 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DNS Round Robin 방식</h3>
<ul>
<li>
<p>DNS Round Robin이란, 별도의 소프트웨어 혹은 하드웨어 로드밸런싱 장비를 사용하지 않고 DNS만을 이용하여 도메인 레코드 정보를 조회하는 시점에서 트래픽을 분산하는 기법이다.</p>
</li>
<li>
<p>웹서버로 예를 들자면, 웹 서비스를 담당할 여러 대의 웹 서버는 자신의 공인 IP를 가지고 있다. 웹 사이트에 접속을 원하는 사용자가 해당 도메인 주소를 브라우저에 입력하면, DNS는 도메인의 정보를 조회하는데, 이때 IP 주소를 여러 대의 서버 IP 리스트 중에서도 라운드 로빈형태로 랜덤하게 하나 혹은 여러개를 선택하여 다시 사용자에게 알려준다. 결과적으로 웹 사이트에 접속하는 다수의 사용자는 실제로는 복수의 웹 서버에 나뉘에 접속하게 되면서 자연스럽게 서버의 부하가 분산되는 방식인 것이다.</p>
</li>
</ul>
<h4 id="dns-round-robin-방식의-문제점" style="position:relative;"><a href="#dns-round-robin-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90" aria-label="dns round robin 방식의 문제점 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DNS Round Robin 방식의 문제점</h4>
<ol>
<li>
<p>부하 분산을 위해 서버의 대수를 늘리기 위해서는 그만큼의 공인 Ip주소가 필요하다.</p>
</li>
<li>
<p>균등하게 분산되지 않는다. 이것은 모바일 사이트 등에서 문제가 될 수 있는데, 스마트폰의 접속은 캐리어 게이트웨이라고 하는 프록시 서버를 경유한다. 프록시 서버에서는 이름변환 결과가 일정 시간 동안 캐싱되므로, 같은 프록시 서버를 경유하는 접속은 항상 같은 서버로 접속된다. 또한 PC용 웹브라우저도 DNS 질의 결과를 캐싱하기 때문에, 균등하게 부하분산되지 않는다. DNS 레코드의 TTL 값을 짧게 설정함으로써 어느정도 해소가 되지만, TTL에 따라 캐시를 해제하는 것은 아니므로 주의가 필요하다.<br>
<em>TTL(time-to-live) : 패킷이 라우터에서 폐기되기 전에 네트워크 내에서 존재하도록 설정된 시간 또는 홉(hop : 소스와 목적지 간의 경로)</em></p>
</li>
<li>
<p>서버가 다운 되어도 확인이 불가능하다. DNS서버는 웹 서버의 부하나 접속 수 등의 상황에 따라 질의결과를 제어할 수가 없다. 웹서버의 부하가 높아서 응답이 느려지거나 접속수가 꽉 차서 접속을 처리할 수 없는 상황인지를 전혀 감지할 수가 없기 때문에, 어떤 원인으로 다운이 되더라도 이를 검출하지 못하고 유저들에게 제공한다. 이때문에 유저들은 간혹 다운된 서버로 연결이 되기도 한다. DNS Round Robin은 어디까지나 부하분산을 위한 방법이지, 다중화 방법은 아니므로 다른 S/W와 조합해서 관리할 필요가 있다.</p>
</li>
</ol>
<h4 id="문제점-해소-기법" style="position:relative;"><a href="#%EB%AC%B8%EC%A0%9C%EC%A0%90-%ED%95%B4%EC%86%8C-%EA%B8%B0%EB%B2%95" aria-label="문제점 해소 기법 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>문제점 해소 기법</h4>
<p>Round Robin 방식을 기반으로, 단점을 해소하는 DNS 스케줄링 알고리즘이 존재한다(일부만 소개)</p>
<h5>Weighted Round Robin(WRR)</h5>
<p>각각의 웹 서버에 가중치를 가미해서 분산 비율을 변경한다. 물론 가중치가 큰 서버일수록 빈번하게 선택되므로 처리 능력이 높은 서버는 가중치를 높게 설정하는 것이 좋다.</p>
<h5>Least Connection</h5>
<p>접속 클라이언트 수가 가장 적은 서버를 선택한다. 로드밸런서에서 실시간으로 connection 수를 관리하거나, 각 서버에서 주기적으로 알려주는 것이 필요하다.</p>
<h3 id="웹-통신의-큰-흐름---우리가-chrome을-실행시켜-주소창에-특정-url값을-입력시키면-어떤-일이-일어날까" style="position:relative;"><a href="#%EC%9B%B9-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%81%B0-%ED%9D%90%EB%A6%84---%EC%9A%B0%EB%A6%AC%EA%B0%80-chrome%EC%9D%84-%EC%8B%A4%ED%96%89%EC%8B%9C%EC%BC%9C-%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-%ED%8A%B9%EC%A0%95-url%EA%B0%92%EC%9D%84-%EC%9E%85%EB%A0%A5%EC%8B%9C%ED%82%A4%EB%A9%B4-%EC%96%B4%EB%96%A4-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C" aria-label="웹 통신의 큰 흐름   우리가 chrome을 실행시켜 주소창에 특정 url값을 입력시키면 어떤 일이 일어날까 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>웹 통신의 큰 흐름 - 우리가 chrome을 실행시켜 주소창에 특정 URL값을 입력시키면 어떤 일이 일어날까?</h3>
<h4 id="in-브라우저" style="position:relative;"><a href="#in-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80" aria-label="in 브라우저 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>in 브라우저</h4>
<ol>
<li>url에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다.</li>
<li>조사된 의미에 따라 HTTP Request 메시지를 만든다.</li>
<li>만들어진 메시지를 웹 서버로 전송한다.</li>
</ol>
<p>이때 만들어진 메시지 전송은 브라우저가 직접 하는 것이 아니다. 브라우저는 메시지를 네트워크에 송출하는 기능이 없으므로 OS에 의뢰하여 메시지를 전달한다. 우리가 택배를 보낼 때 직접 보내는 게 아니라, 이미 서비스가 이루어지고 있는 택배 시스템을 이용하여 보내는 것과 같은 이치이다. 단, OS에 송신을 의뢰할 때는 도메인 명이 아니라 IP주소로 메시지를 받을 상대를 지정해야 하는데, 이 과정에서 DNS서버를 조회해야 한다.</p>
<h4 id="in-프로토콜-스택-lan-어댑터" style="position:relative;"><a href="#in-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D-lan-%EC%96%B4%EB%8C%91%ED%84%B0" aria-label="in 프로토콜 스택 lan 어댑터 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>in 프로토콜 스택, LAN 어댑터</h4>
<ol>
<li>프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어)이 브라우저로부터 메시지를 받는다.</li>
<li>브라우저로부터 받은 메시지를 패킷 속에 저장한다.</li>
<li>수신처 주소 등의 제어정보를 덧붙인다.</li>
<li>패킷을 LAN어댑터에 넘긴다.</li>
<li>LAN 어댑터는 다음 Hop의 MAC주소를 붙인 프레임을 전기신호로 변환시킨다.</li>
<li>신호를 LAN케이블에 송출시킨다.</li>
</ol>
<p>프로토콜 스택은 통신 중 오류가 발생했을 때, 이 제어 정보를 사용하여 고쳐 보내거나, 각종 상황을 조절하는 등의 다양한 역할을 하게 된다. 네트워크 세계에서는 비서가 있어서 우리가 비서에게 물건만 건네주면, 받는 사람의 주소와 각종 유의사항을 써준다. 여기서는 프로토콜 스택이 비서의 역할을 한다고 볼 수 있다.</p>
<h4 id="in-허브-스위치-라우터" style="position:relative;"><a href="#in-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0" aria-label="in 허브 스위치 라우터 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>in 허브, 스위치, 라우터</h4>
<ol>
<li>LAN 어댑터가 송신한 프레임은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다.</li>
<li>라우터는 패킷을 프로바이더(통신사)에게 전달한다.</li>
<li>인터넷으로 들어가게 된다.</li>
</ol>
<h4 id="in-액세스-회선-프로바이더" style="position:relative;"><a href="#in-%EC%95%A1%EC%84%B8%EC%8A%A4-%ED%9A%8C%EC%84%A0-%ED%94%84%EB%A1%9C%EB%B0%94%EC%9D%B4%EB%8D%94" aria-label="in 액세스 회선 프로바이더 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>in 액세스 회선, 프로바이더</h4>
<ol>
<li>패킷은 인터넷의 입구에 있는 액세스 회선(통신 회선)에 의해 POP(point of presence, 통신사용 라우터)까지 운반된다.</li>
<li>POP를 거쳐 인터넷의 핵심부로 들어가게 된다.</li>
<li>수 많은 고속 라우터들 사이로 패킷이 목적지를 향해 흘러가게 된다.</li>
</ol>
<h4 id="in-방화벽-캐시서버" style="position:relative;"><a href="#in-%EB%B0%A9%ED%99%94%EB%B2%BD-%EC%BA%90%EC%8B%9C%EC%84%9C%EB%B2%84" aria-label="in 방화벽 캐시서버 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>in 방화벽, 캐시서버</h4>
<ol>
<li>패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN에 도착한다.</li>
<li>기다리고 있던 방화벽이 도착한 패킷을 검사한다.</li>
<li>패킷이 웹 서버까지 가야하는지 가지 않아도 되는지를 판단하는 캐시 서버가 존재한다.</li>
</ol>
<p>굳이 서버까지 가지 않아도 되는 경우를 골라낸다. 액세스한 페이지의 데이터가 캐시서버에 있으면, 웹 서버에 의뢰하지 않고 바로 그 값을 읽을 수 있다. 페이지의 데이터 중에 다시 이용할 수 있는 것이 있으면 캐시 서버에 저장된다.</p>
<h4 id="in-웹서버" style="position:relative;"><a href="#in-%EC%9B%B9%EC%84%9C%EB%B2%84" aria-label="in 웹서버 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>in 웹서버</h4>
<ol>
<li>패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘긴다.</li>
<li>메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송한다.</li>
<li>왔던 방식대로 응답 메시지가 클라이언트에게 전송된다.</li>
</ol>
<h2 id="1-4-운영체제" style="position:relative;"><a href="#1-4-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C" aria-label="1 4 운영체제 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1-4. 운영체제</h2>
<h3 id="프로세스와-스레드의-차이" style="position:relative;"><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4" aria-label="프로세스와 스레드의 차이 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로세스와 스레드의 차이</h3>
<h4 id="프로세스process" style="position:relative;"><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4process" aria-label="프로세스process permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로세스(Process)</h4>
<p>프로세스는 실행중인 프로그램으로, 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며, 이것들을 총칭하여 프로세스라고 한다. 구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소, 로컬변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다.</p>
<h5>프로세스 제어 블록(Process Control Block, PCB)</h5>
<p>PCB는 <strong>특정 프로세스에 대한 중요한 정보를 저장</strong>하고 있는 운영체제의 자료구조이다. 운영체제는 프로세스를 관리하기 위해 <strong>프로세스의 생성과 동시에 고유한 PCB를 생성</strong>한다. 프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하게 되면 진행하던 작업을 저장하고 CPU를 반환해야하는데, 이때 작업의 진행 상황을 모두 PCB에 저장하게 된다. 그리고 다시 CPU를 할당받게 되면 PCB에 저장되어있던 내용들을 불러와 이전에 종료했던 시점부터 다시 작업을 수행한다.</p>
<h6>PCB에 저장되는 정보</h6>
<ul>
<li>프로세스 식별자(Process ID,PID) : 프로세스 식별 번호</li>
<li>프로세스 상태 : new, ready, waiting, terminated 등의 상태를 저장</li>
<li>프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소</li>
<li>CPU 레지스터</li>
<li>CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케쥴 큐에 대한 포인터 등</li>
<li>메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함</li>
<li>입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록</li>
<li>어카운팅 정보 : 사용된 CPU시간, 시간 제한, 계정번호 등</li>
</ul>
<h4 id="스레드thread" style="position:relative;"><a href="#%EC%8A%A4%EB%A0%88%EB%93%9Cthread" aria-label="스레드thread permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>스레드(Thread)</h4>
<p>스레드는 프로세스의 실행 단위라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다. 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 웅영체제 자원들을 공유한다. 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 한다. 이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC레지스터 값을 갖고 있다.</p>
<h5>스택을 스레드마다 독립적으로 할당하는 이유</h5>
<p>스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로, 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고, 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.</p>
<h5>PC Register를 스레드마다 독립적으로 할당하는 이유</h5>
<p>PC값은 스레드가 명령어의 어디까지 수행하였는지를 나타내게 된다. 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC레지스터를 독립적으로 할당한다.</p>
<h3 id="멀티-스레드" style="position:relative;"><a href="#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C" aria-label="멀티 스레드 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>멀티 스레드</h3>
<h4 id="멀티-스레딩의-장점" style="position:relative;"><a href="#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%94%A9%EC%9D%98-%EC%9E%A5%EC%A0%90" aria-label="멀티 스레딩의 장점 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>멀티 스레딩의 장점</h4>
<p>프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우, 메모리 공간과 시스템 자원 소모가 줄어들게 된다. 스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라, 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용하여 데이터를 주고받을 수 있다. 그렇기 때문에 프로세스 간 통신 방법에 비해 스레드 간의 통신 방법이 훨씬 간단하다. 심지어 스레드의 context switch는 프로세스 context switch와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다. 따라서 시스템의 throughtput이 향상되고 자원소모가 줄어들며, 자연스럽게 프로그램의 응답 시간이 단축된다. 이러한 장점때문에, 여러 프로세스로 할 수 있는 작업들을 하나의 프로세스에서 스레드로 나눠 수행하는 것이다.</p>
<h4 id="멀티-스레딩의-문제점" style="position:relative;"><a href="#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%94%A9%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90" aria-label="멀티 스레딩의 문제점 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>멀티 스레딩의 문제점</h4>
<ul>
<li>
<p>멀티 프로세스 기반으로 프로그래밍을 할 때에는 프로스세 간 공유하는 자원이 없기 때문에, 동일한 자원에 동시에 접근하는 일이 없었지만 멀티 스레딩을 기반으로 프로그래밍을 할 때에는 이 부분을 신경써줘야 한다. 서로 다른 스레드가 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.</p>
</li>
<li>
<p>그렇기 때문에 멀티 스레딩 환경에서는 동기화 작업이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤하는 것이다. 하지만 이로 인해 병목 현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락으로 인한 병목현상을 줄여야한다.</p>
</li>
</ul>
<h4 id="멀티-스레드-vs-멀티-프로세스" style="position:relative;"><a href="#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C-vs-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4" aria-label="멀티 스레드 vs 멀티 프로세스 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>멀티 스레드 vs 멀티 프로세스</h4>
<p>멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고, 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다. 반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU시간을 차지한다는 단점이 존재한다. 이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합 / 부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.</p>
<h3 id="스케줄러" style="position:relative;"><a href="#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC" aria-label="스케줄러 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>스케줄러</h3>
<p>프로세스를 스케줄링 하기 위한 Queue에는 세 가지 종류가 존재한다.</p>
<ul>
<li>Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합</li>
<li>Ready Queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합</li>
<li>Device Queue : Device I/O 작업을 대기하고 있는 프로세스의 집합</li>
</ul>
<p>각각의 Queue에 프로세스들을 넣고 빼주는 스케줄러에도 크게 세 가지 종류가 존재한다.</p>
<h4 id="장기-스케줄러long-term-scheduler-or-job-scheduler" style="position:relative;"><a href="#%EC%9E%A5%EA%B8%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AClong-term-scheduler-or-job-scheduler" aria-label="장기 스케줄러long term scheduler or job scheduler permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>장기 스케줄러(Long-term scheduler or job scheduler)</h4>
<p>메모리는 한정되어 있는데, 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장된다. 이 pool에 저장되어 있는 프로스세 중에서 어떤 프로세스에 메모리를 할당하여 ready queue로 보낼지 결정하는 역할을 한다.</p>
<ul>
<li>메모리와 디스크 사이의 스케줄링을 담당</li>
<li>프로세스에 memory(및 각종 리스소)를 할당(admit)</li>
<li>degree of Multiprogramming 제어(실행중인 프로세스의 수 제어)</li>
<li>프로세스의 상태(new -> ready(in memory))</li>
</ul>
<p><em>cf)메모리에 프로그램이 너무 많이 올라가도, 너무 적게 올라가도, 성능이 좋지 않은 것이다. 참고로 time sharing system에서는 장기 스케줄러가 없다. 그냥 곧바로 메모리에 올라가 ready 상태가 된다.</em></p>
<h4 id="단기-스케줄러short-term-scheduler-or-cpu-scheduler" style="position:relative;"><a href="#%EB%8B%A8%EA%B8%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%ACshort-term-scheduler-or-cpu-scheduler" aria-label="단기 스케줄러short term scheduler or cpu scheduler permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>단기 스케줄러(Short-term scheduler or CPU scheduler)</h4>
<ul>
<li>cpu와 메모리 사이의 스케줄링을 담당</li>
<li>Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정</li>
<li>프로세스에 CPU를 할당(scheduler dispatch)</li>
<li>프로세스의 상태(ready -> running -> waiting -> ready)</li>
</ul>
<h4 id="중기-스케줄러medium-term-scheduler-or-swapper" style="position:relative;"><a href="#%EC%A4%91%EA%B8%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%ACmedium-term-scheduler-or-swapper" aria-label="중기 스케줄러medium term scheduler or swapper permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>중기 스케줄러(Medium-term scheduler or Swapper)</h4>
<ul>
<li>여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄(swapping)</li>
<li>프로세스에게서 memory를 deallocate</li>
<li>degree of Multiprogrammin 제어</li>
<li>현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러</li>
<li>프로세스의 상태(ready -> suspended)</li>
</ul>
<p><strong>Process State - suspended</strong></p>
<p>suspended(stopped) : 외부적인 이유로 프로세스의 수행이 정지된 상태로, 메모리에서 내려간 상태를 의미한다. 모든 프로세스가 디스크로 swap out된다. blocked 상태는 다른 I/O 작업을 기다리는 상태이기 때문에 스스로 ready state로 돌아갈 수 있지만, 이 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다.</p>
<h3 id="cpu-스케줄러" style="position:relative;"><a href="#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC" aria-label="cpu 스케줄러 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CPU 스케줄러</h3>
<p><em>스케줄링 대상은 Ready Queue에 있는 프로세스들이다.</em></p>
<h4 id="fcfsfirst-come-first-saved" style="position:relative;"><a href="#fcfsfirst-come-first-saved" aria-label="fcfsfirst come first saved permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>FCFS(First Come First Saved)</h4>
<h5>특징</h5>
<ul>
<li>먼저 온 고객을 먼저 서비스 해주는 방식, 즉 먼저 온 순서대로 처리.</li>
<li>비선점형(Non-Peemptive) 스케줄링 : 일단 CPU를 잡으면 CPU burst가 완료될 때까지 CPU를 반환하지 않는다. 할당되었던 CPU가 반환할 때만 스케줄링이 이루어진다.</li>
</ul>
<h5>문제점</h5>
<ul>
<li>convoy effect : 소요시간이 긴 프로세스가 먼저 도달하면 효율성이 낮아지는 현상이 발생한다.</li>
</ul>
<h4 id="sjfshortest-job-first" style="position:relative;"><a href="#sjfshortest-job-first" aria-label="sjfshortest job first permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SJF(Shortest Job First)</h4>
<h5>특징</h5>
<ul>
<li>다른 프로세스가 먼저 도착했어도 CPU burst time이 짧은 프로세스에게 선 할당</li>
<li>비선점형 스케줄링</li>
</ul>
<h5>문제점</h5>
<ul>
<li>starvation : 효율성을 추구하는 게 가장 중요하지만, 특정 프로세스가 지나치게 차별받으면 안된다. 이 스케줄링은 극단적으로 CPU 사용이 짧은 job을 선호한다. 그레서 사용시간이 긴 프로세스는 거의 영원히 CPU를 할당받을 수 없다.</li>
</ul>
<h4 id="srtfshortest-remaining-time-first" style="position:relative;"><a href="#srtfshortest-remaining-time-first" aria-label="srtfshortest remaining time first permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SRTF(Shortest Remaining Time First)</h4>
<h5>특징</h5>
<ul>
<li>새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.</li>
<li>선점형(Preemptive) 스케줄링 : 현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 뺏긴다.</li>
</ul>
<h5>문제점</h5>
<ul>
<li>starvation</li>
<li>새로운 프로세스가 도달할 때마다 스케줄링을 다시 하기 때문에, CPU burst time(CPU 사용시간)을 측정할 수가 없다.</li>
</ul>
<h4 id="priority-scheduling" style="position:relative;"><a href="#priority-scheduling" aria-label="priority scheduling permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Priority Scheduling</h4>
<h5>특징</h5>
<ul>
<li>우선순위가 가장 높은 프로세스에게 CPU를 할당하는 스케줄링이다. 우선순위란 정수로 표한하게 되고, 작은 숫자가 우선순위가 높다.</li>
<li>선점형 스케줄링 방식 : 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점한다.</li>
<li>비선점형 스케줄링 방식 : 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 head에 넣는다.</li>
</ul>
<h5>문제점</h5>
<ul>
<li>starvation</li>
<li>무기한 봉쇄(Indefinite Blocking) : 실행 준비는 되어있으나, CPU를 사용하지 못하는 프로세스를 CPU가 무기한 대기시키는 상태</li>
</ul>
<h5>해결책</h5>
<ul>
<li>aging : 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주자.</li>
</ul>
<h4 id="rrround-robin" style="position:relative;"><a href="#rrround-robin" aria-label="rrround robin permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RR(Round Robin)</h4>
<h5>특징</h5>
<ul>
<li>현대적인 CPU 스케줄링</li>
<li>각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.</li>
<li>할당 시간이 지나면 프로세스는 선점당하고 Ready Queue의 제일 뒤에 가서 다시 줄을 선다.</li>
<li>RR은 CPU 사용시간이 랜덤한 프로세스 모임에 효율적이다.</li>
<li>RR이 가능한 이유는 프로세스의 context를 save 할 수 있기 때문이다.</li>
</ul>
<h5>장점</h5>
<ul>
<li>Response time이 빨라짐 : n개의 프로세스가 ready queue에 있고 할당시간이 q(time quantum)인 경우, 각 프로스세는 q 단위로 CPU 시간의 1/n을 얻는다. 즉 어떤 프로세스도 (n - 1)q time unit 이상을 기다리지 않는다.</li>
<li>프로세스가 기다리는 시간이 CPU를 사용하는 만큼 증가함 : 공정한 스케줄링이라고 할 수 있다.</li>
</ul>
<h5>주의할 점</h5>
<p>설정한 time quantum이 너무 커지면 FCFS와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch로, overhead가 발생한다. 그렇기 때문에 적당한 time quantum을 설정하는 것이 중요하다.</p>
<h3 id="동기와-비동기의-차이" style="position:relative;"><a href="#%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%9D%98-%EC%B0%A8%EC%9D%B4" aria-label="동기와 비동기의 차이 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>동기와 비동기의 차이</h3>
<h4 id="비유를-통한-쉬운-설명" style="position:relative;"><a href="#%EB%B9%84%EC%9C%A0%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%89%AC%EC%9A%B4-%EC%84%A4%EB%AA%85" aria-label="비유를 통한 쉬운 설명 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>비유를 통한 쉬운 설명</h4>
<p>해야할 일(task)가 빨래, 설저기, 청소 세 가지가 있다고 가정한다. 이 이들을 동기적으로 처리한다면 빨래를 하고 설거지를 하고 청소를 순서대로 한다. 비동기적으로 일을 처리한다면 빨래하는 업체에게 빨래를 시키고, 설거지 또한 업체에 대행하고, 청소도 그와 같이 한다. 셋 중에 어떤 것이 먼저 완료될는지는 알 수 없다. 일을 모두 마친 업체는 나에게 알려주기로 했으니, 나는 다른 작업을 할 수 있다. 이때는 백그라운드 스레드에서 해당 작업을 처리하는 경우의 비동기를 의미한다.</p>
<h4 id="sync-vs-async" style="position:relative;"><a href="#sync-vs-async" aria-label="sync vs async permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sync vs Async</h4>
<p>일반적으로 동기와 비동기의 차이는, 메소드를 실행시킴과 동시에 반환 값이 기대되는 경우를 <strong>동기</strong>라고 표현하고, 그렇지 않은 경우를 <strong>비동기</strong>라고 표현한다. 동시에라는 말은 실행되었을 때 값이 반환되기 전까지는 <code class="language-text">blocking</code>되어 있다는 것을 의미한다. 비동기의 경우, <code class="language-text">blocking</code>되지 않고, 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task를 위임하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.</p>
<h3 id="프로세스-동기화" style="position:relative;"><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94" aria-label="프로세스 동기화 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로세스 동기화</h3>
<h4 id="critical-section임계영역" style="position:relative;"><a href="#critical-section%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD" aria-label="critical section임계영역 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Critical Section(임계영역)</h4>
<p>멀티 스레딩에 문제점에서 나오듯, 동일한 자원을 동시에 접근하는 작업(e.g.공유하는 변수 사용, 동일 파일을 사용)을 실행하는 코드 영역을 Critical Section이라고 한다.</p>
<h4 id="critical-section-problem임계영역-문제" style="position:relative;"><a href="#critical-section-problem%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD-%EB%AC%B8%EC%A0%9C" aria-label="critical section problem임계영역 문제 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Critical Section Problem(임계영역 문제)</h4>
<p>프로세스들이 Critical Section을 함께 사용할 수 있는 프로토콜을 설계하는 것이다.</p>
<h4 id="requirements해결을-위한-기본조건" style="position:relative;"><a href="#requirements%ED%95%B4%EA%B2%B0%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B8%B0%EB%B3%B8%EC%A1%B0%EA%B1%B4" aria-label="requirements해결을 위한 기본조건 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Requirements(해결을 위한 기본조건)</h4>
<ul>
<li>Mutual Exclusion(상호 배제)<br>
프로세스 P1이 Ciritical Section에서 실행중이라면, 다른 프로세스들은 그들이 가진 Ciritical Section에서 실행될 수 없다.</li>
<li>Progress(진행)<br>
Ciritical Section에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Ciritical Section 진입 후보로서 참여될 수 있다.</li>
<li>Bounded Waiting(한정된 대기)<br>
P1가 Critical Section에 진입 신청 후부터 받아들여질 때까지, 다른 프로세스들이 Ciritical Section에 진입하는 횟수는 제한이 있어야 한다.</li>
</ul>
<h4 id="해결책" style="position:relative;"><a href="#%ED%95%B4%EA%B2%B0%EC%B1%85" aria-label="해결책 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>해결책</h4>
<h5>Lock</h5>
<p>하드웨어 기반 해결책으로써, 동시에 공유 자원에 접근하는 것을 막기 위해 Ciritical Section에 진입하는 프로세스는 Lock을 획득하고, Critical Section을 빠져나올 때 Lock을 방출함으로써 동시에 접근이 되지 않도록 한다.</p>
<h6>한계</h6>
<p>다중처리기 환경에서는 시간적인 효율성 측면에서 적용할 수 없다.</p>
<h5>Semaphores(세마포어)</h5>
<p>소프트웨어상에서 Ciritical Section 문제를 해결하기 위한 동기화 도구</p>
<h6>종류</h6>
<p>OS는 Counting / Binary 세마포어를 구분한다.</p>
<ul>
<li>카운팅 세마포어<br>
<strong>사용 가능한 자원</strong>에 대한 접근 제어용으로 사용되며, 세마포어는 그 사용 가능한 자원의 개수로 초기화된다. 자원을 사용하면 세마포어가 감소, 방출하면 세마포어가 증가한다.</li>
<li>이진 세마포어<br>
MUTEX라고도 불리며, 상호배제(Mutual Exclusion)의 머릿글자를 따서 만들어졌다. 이름 그대로 0과 1의 값만 가능하며, 다중 프로세스들 사이의 Ciritical Section 문제를 해결하기 위해 사용된다.</li>
</ul>
<h6>단점</h6>
<ul>
<li>
<p>Busy waiting(바쁜 대기)<br>
Spin lock이라고 불리는 Semaphore 초기 버전에서 Ciritical Section에 진입해야 하는 프로세스는 진입 코드를 계속 반복 실행해야 하며, CPU시간을 낭비했었다. 이를 Busy Waiting이라고 부르며, 특수한 상황이 아니면 <strong>비효율적</strong>이다. 일반적으로는 세마포어에서 Ciritical Section에 진입을 시도했지만 실패한 프로세스에 대해 Block 시킨 뒤, Critical Section에 자리가 날 때 다시 깨우는 방식을 사용한다. 이 경우 Busy Waiting으로 인한 시간낭비 문제가 해결된다.</p>
</li>
<li>
<p>Deadlock(교착상태)<br>
세마포어가 Ready Queue를 갖고 있고, 둘 이상의 프로세스가 Ciritical Section 진입을 무한정 기다리고 있고, Critical Section에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되어야만 빠져나올 수 있는 상황을 지칭한다.</p>
</li>
</ul>
<h5>모니터</h5>
<ul>
<li>고급 언어의 설계 구조물로써, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태이다.</li>
<li>공유 자원에 접근하기 위한 키 획득과 자원 사용 후 해제를 모두 처리한다.(세마포어는 직접 키 해제와 공유자원 접근 처리가 필요하다.)</li>
</ul>
<h3 id="메모리-관리-전략" style="position:relative;"><a href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5" aria-label="메모리 관리 전략 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>메모리 관리 전략</h3>
<h4 id="메모리-관리-배경" style="position:relative;"><a href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%B0%B0%EA%B2%BD" aria-label="메모리 관리 배경 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>메모리 관리 배경</h4>
<p>각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 오직 <strong>운영체제</strong>만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.</p>
<p><strong>Swapping</strong> : 메모리의 관리를 위해 사용되는 기법으로, 표준 Swapping 방식으로는 round-robin과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드 디스크)로 내보내고 다른 프로세스의 메모리를 불러들일 수 있다.</p>
<blockquote>
<p>이 과정을 swap이라고 한다.주 기억장치(RAM)으로 불러오는 과정을 swap-in, 보조기억장치로 내보내는 과정을 swap-out이라고 한다. swap에는 큰 디스크 전송시간이 필요하기 때문에, 현재에는 메모리 공간이 부족할 때 swapping이 시작된다.</p>
</blockquote>
<p><strong>단편화(Fragmentation)</strong> : 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 단편화이다. 단편화는 두 가지 종류로 나뉜다.</p>
<table>
<thead>
<tr>
<th><code class="language-text">Process A</code></th>
<th>free</th>
<th><code class="language-text">Process B</code></th>
<th>free</th>
<th><code class="language-text">Process C</code></th>
<th>free</th>
<th><code class="language-text">Process D</code></th>
</tr>
</thead>
</table>
<ul>
<li>외부 단편화<br>
메모리 공간 중에서 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 <strong>분산되어 있을 때 발생한다고 볼 수 있다</strong>.</li>
<li>내부 단편화<br>
프로세스가 사용하는 메모리 공간에 포함된 남는 부분. 예를들어 메모리 분할 자유 공간이 10,000B 있고, process A가 9,998B 사용하게되면, 2B라는 차이가 존재하고, 이 현상을 내부 단편화라 칭한다.</li>
</ul>
<p><strong>압축</strong> : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론이지만, 작업효율이 좋지 않다.(위의 메모리 현황이 압축을 통해 아래의 그림처럼 바뀌는 효과를 기대할 수 있다.)</p>
<table>
<thead>
<tr>
<th><code class="language-text">Process A</code></th>
<th><code class="language-text">Process B</code></th>
<th><code class="language-text">Process C</code></th>
<th><code class="language-text">Process D</code></th>
<th>free</th>
</tr>
</thead>
</table>
<h4 id="paging페이징" style="position:relative;"><a href="#paging%ED%8E%98%EC%9D%B4%EC%A7%95" aria-label="paging페이징 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Paging(페이징)</h4>
<p>하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로, 물리 메모리는 <code class="language-text">Frame</code>이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는 메모리)는 <code class="language-text">Page</code>라 불리는 고정크기의 블록으로 분리된다.(페이지 교체 알고리즘에 들어가는 page)</p>
<p>페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로써 외부 단편화를 해결할 수 있는 큰 장점이 된다.</p>
<p>하나의 프로세스가 사용하는 공간은 여러 개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장된다고 볼 수 있다.</p>
<ul>
<li>단점 : 내부 단편화 문제의 비중이 늘어나게 된다. 예를 들어 페이지 크기가 1,024B이고, 프로세스 A가 3,172B의 메모리를 요구한다면 3개의 페이지 프레임(1,024 * 3 = 3,072)하고도 100B가 남기 때문에, 4개의 페이지 프레임이 필요한 것이다. 결론적으로는 4번째 페이지 프레임에는 924B의 여유 공간이 남게되는 내부 단편화 문제가 발생하는 것이다.</li>
</ul>
<h4 id="segmentation세그멘테이션" style="position:relative;"><a href="#segmentation%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98" aria-label="segmentation세그멘테이션 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Segmentation(세그멘테이션)</h4>
<p>페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위)한다. 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장한다.</p>
<ul>
<li>단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자쥬 공간들이 많은 수의 작은 조각들로 나뉘어져 못 쓰게 될 수도 있다.(외부 단편화)</li>
</ul>
<h3 id="가상-메모리" style="position:relative;"><a href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC" aria-label="가상 메모리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>가상 메모리</h3>
<p>다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야한다. 가상 메모리는 <strong>프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법</strong>이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.</p>
<h4 id="가상-메모리-개발-배경" style="position:relative;"><a href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%9C%EB%B0%9C-%EB%B0%B0%EA%B2%BD" aria-label="가상 메모리 개발 배경 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>가상 메모리 개발 배경</h4>
<p>실행되는 코드의 전부를 물리 메모리에 존재시켜야했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었다. 또한, 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와 페이지 교체 등의 성능 이슈가 발생하게 된다. 또한, 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점에서 불필요하게 전체의 프로그램이 메모리에 올라와 있어야 하는 게 아니라는 것을 알 수 있다.</p>
<p><strong>프로그램의 일부분만 메모리에 올릴 수 있다면...</strong></p>
<ul>
<li>물리 메모리 크기에 제약받지 않게 된다.</li>
<li>더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 <code class="language-text">응답시간</code>은 유지되고, <code class="language-text">CPU이용률</code>과 <code class="language-text">처리율</code>은 높아진다.</li>
<li>swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.</li>
</ul>
<h4 id="가상-메모리가-하는-일" style="position:relative;"><a href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%ED%95%98%EB%8A%94-%EC%9D%BC" aria-label="가상 메모리가 하는 일 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>가상 메모리가 하는 일</h4>
<p>가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다. 이로써 작은 메모리를 가지고도 얼마든지 큰 <code class="language-text">가상 주소 공간</code>을 프로그래머에게 제공할 수 있다.</p>
<h5>가상 주소 공간</h5>
<ul>
<li>한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다. 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로써, 현재 직접적으로 필요치 않은 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.</li>
<li>예를 들어, 한 프로그램이 실행되는 논리 메모리로 100KB가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간(Heap영역, Stack영역, 코드, 데이터)의 합이 40KB라면, 실제 물리 메모리에는 40KB만 올라가 있고, 나머지 60KB만큼은 필요시에 물리 메모리에 요구한다고 이해할 수 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>Stack</th>
<th>free(60kb)</th>
<th>Heap</th>
<th>Data</th>
<th>Code</th>
</tr>
</thead>
</table>
<h5>프로세스 간의 페이지 공유</h5>
<p>가상 메모리는...</p>
<ul>
<li><code class="language-text">시스템 라이브러리</code>가 여러 프로세스들 사이에 공유될 수 있도록 한다. 각 프로세스들은 <code class="language-text">공유 라이브러리</code>를 자신의 가상 주소 공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가있는 <code class="language-text">물리 메모리 페이지</code>들은 모든 프로세스에 공유되고 있다.</li>
<li>프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있다. 이 또한, 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만 실제 물리 메모리는 공유되고 있다.</li>
<li>fork()를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다.</li>
</ul>
<h4 id="demand-paging요구-페이징" style="position:relative;"><a href="#demand-paging%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95" aria-label="demand paging요구 페이징 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Demand Paging(요구 페이징)</h4>
<p>프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 <code class="language-text">요구 페이징</code>이라 하며, 가상 메모리 시스템에서 많이 사용된다. 그리고 가상 메모리는 대개 페이지로 관리된다. 요구 페이징을 사용하는 가상 메모리에서는 실행 과정에서 필요해질 때 페이지들이 적재된다. 한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.</p>
<p>프로세스 내의 개별 페이지들인 <code class="language-text">페이저(pager)</code>에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옴으로써, <code class="language-text">사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비</code>를 줄일 수 있다.</p>
<h4 id="페이지-부재" style="position:relative;"><a href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC" aria-label="페이지 부재 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>페이지 부재</h4>
<p>CPU에 요청한 페이지가 현재 메모리에 없어 <code class="language-text">유효-무효 비트</code>가 무효로 세팅되어 있는 경우를 말한다. 페이지 부재 발생 시에 페이지를 디스크에서 읽어와야 하는데, 이 과정에서 막대한 overhead가 발생한다. 따라서 요구 페이징 기법은 페이지 부재 발생률이 성능에 높은 영향을 미친다.</p>
<h5>페이지 부재 시 동작 과정</h5>
<ol>
<li>MMU(Memory Management Unit)가 페이지 부재 트랩(Page Fault Trap)을 발생시킨다.(트랩 = 소프트웨어 인터럽트)</li>
<li>인터럽트로 인해 커널모드로 전환되어 OS의 페이지 부재 처리 루틴이 호출된다.</li>
<li>해당 부재 페이지의 보호비트를 참조해 접근이 가능한지 체크한다.</li>
<li>물리 메모리에 비어있는 프레임을 할당받고 그곳에 피이지를 읽어온다.</li>
<li>페이지를 읽어오는 동안 프로세스는 wait 상태가 된다.</li>
<li>디스크를 입출력 완료 시, 인터럽트를 발생시키고 해당 페이지의 <code class="language-text">유효-무효 비트</code>를 유효로 세팅한다.</li>
</ol>
<h4 id="페이지-교체" style="position:relative;"><a href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4" aria-label="페이지 교체 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>페이지 교체</h4>
<p><code class="language-text">요구 페이징</code>에서 언급된대로 프로그램 실행 시에 모든 항목이 물리 메모리에 올라오지는 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 <code class="language-text">page fault(페이지 부재)</code>가 발생하게 되면, 원하는 페이지를 보조 저장 장치에서 가져오게 된다. 하지만, 만약 물리 메모리가 모두 사용 중인 상황이라면 페이지 교체가 이루어져야 한다.(또는, 운영체제가 프로세스를 강제 종료하는 방법이 있다.)</p>
<h5>기본적인 방법</h5>
<p>물리 메모리가 모두 사용중인 상황에서의 메모리 교체 흐름이다.</p>
<ol>
<li>디스크에서 필요한 페이지의 위치를 찾는다.</li>
<li>빈 페이지 프레임을 찾는다.<br>
i. <code class="language-text">페이지 교체 알고리즘</code>을 통해 희생(victim)될 페이지를 고른다.<br>
ii. 희생될 페이지를 디스크에 기록하고 관련 페이지 테이블을 수정한다.</li>
<li>새롭게 비워진 페이지 테이블 내의 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.</li>
<li>사용자 프로세스 재시작</li>
</ol>
<h5>페이지 교체 알고리즘</h5>
<h6>FIFO 페이지 교체</h6>
<p>가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.</p>
<ul>
<li>장점
<ul>
<li>이해하기도 쉽고, 프로그램 하기도 쉽다.</li>
</ul>
</li>
<li>단점
<ul>
<li>오래된 페이지가 항상 불필요 하지 않는 정보를 포함하지 않을 수 있다(초기 변수 등).</li>
<li>처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.</li>
<li><code class="language-text">Belady의 모순</code> : 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도, 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.</li>
</ul>
</li>
</ul>
<h6>최적 페이지 교체(OPT : OPTimal page replacement)</h6>
<p><code class="language-text">Belady의 모순</code>을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 <code class="language-text">Belady의 모순</code>이 발생하지 않는다. 이 알고리즘의 핵심은 <strong>앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체</strong>하는 것이다. 주로 비교 연구 목적을 위해 사용한다.</p>
<ul>
<li>장점
<ul>
<li>알고리즘 중 가장 낮은 페이지 부재율을 보장한다.</li>
</ul>
</li>
<li>단점
<ul>
<li>구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.</li>
</ul>
</li>
</ul>
<h6>LRU 페이지 교체(LRU Page Replacement)</h6>
<p><code class="language-text">LRU : Least Recently Used</code><br>
최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.</p>
<ul>
<li>특징
<ul>
<li>대체적으로 <code class="language-text">FIFO 알고리즘</code>보다 우수하고, <code class="language-text">OPT알고리즘</code>보다는 그렇지 못한 모습을 보인다.</li>
</ul>
</li>
</ul>
<h6>LFU 페이지 교체(LFU Page Replacement)</h6>
<p><code class="language-text">LFU : Least Frequently Used</code><br>
참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.</p>
<ul>
<li>특징
<ul>
<li>어떤 프로세스가 특정 페이지를 집중적으로 사용하다가 다른 기능을 사용하게 되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다.</li>
<li>최적 페이지 교체를 제대로 근사하지 못하기 때문에 잘 사용하지 않는다.</li>
</ul>
</li>
</ul>
<h6>MFU 페이지 교체(MFU Page Replacement)</h6>
<p><code class="language-text">MFU : Most Frequently Used</code><br>
참조 횟수가 적은 페이지가 최근에 참조된 것으로 보고 앞으로도 사용될 가능성이 높다고 판단하여 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다.</p>
<ul>
<li>특징
<ul>
<li>최적 페이지 교체를 제대로 근사하지 못하기 때문에 잘 사용하지 않는다.</li>
</ul>
</li>
</ul>
<h3 id="캐시의-지역성" style="position:relative;"><a href="#%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%A7%80%EC%97%AD%EC%84%B1" aria-label="캐시의 지역성 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>캐시의 지역성</h3>
<h4 id="캐시의-지역성의-원리" style="position:relative;"><a href="#%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%A7%80%EC%97%AD%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC" aria-label="캐시의 지역성의 원리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>캐시의 지역성의 원리</h4>
<p>캐시 메모리는 속도가 빠른 장치와 느린 장치 간의 속도 차에 따른 병목 현상을 줄이기 위한 범용 메모리이다. 이러한 역할을 수행하기 위해서는 CPU가 어떤 데이터를 원할 것인가를 어느정도 예측할 수 있어야 한다. 캐시의 성능은 작은 용량의 캐시 메모리에 CPU가 이후에 참조할, 쓸모있는 정보가 어느정도 들어있냐에 따라 좌우되기 때문이다.</p>
<p>이때 <code class="language-text">적중율(Hit Rate)</code>을 극대화 시키기 위해 데이터 <code class="language-text">지역성(Locality)의 원리</code>를 사용한다. 지역성의 전제조건으로, 프로그램은 모든 코드나 데이터를 균등하게 access 하지 않는다는 특성을 기본으로 한다. 즉, <code class="language-text">Locality</code>란 기억 장치 내의 정보를 균일하게 access 하는 것이 아닌, 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성인 것이다.</p>
<p>이 데이터의 지역성은 대표적으로 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)로 나뉜다.</p>
<ul>
<li>시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성.</li>
<li>공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성</li>
</ul>
<h4 id="caching-line" style="position:relative;"><a href="#caching-line" aria-label="caching line permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Caching Line</h4>
<p>언급했듯이, 캐시(cache)는 프로세서 가까이에 위치하면서 빈번하게 사용되는 데이터를 놔두는 장소이다. 하지만 캐시가 아무리 가까이 있더라도 찾고자 하는 데이터가 어느 곳에 저장되어 있는지를 몰라 모든 데이터를 순회해야 한다면 시간이 오래 걸리게 된다. 즉, 캐시에 목적 데이터가 저장되어 있다면, 바로 접근하여 출력할 수 있어야 캐시가 의미가 있어진다는 것이다.</p>
<p>그렇기 때문에 캐시에 데이터를 저장할 때, 특정 자료구조를 사용하여 <code class="language-text">묶음</code>으로 저장하게 되는데 이를 <strong>캐싱 라인</strong>이라고 한다. 프로세스는 다양한 주소에 있는 데이터를 사용하므로 빈번하게 사용하는 데이터의 주소 또한 흩어져 있다. 따라서 캐시에 저장하는 데이터에는 데이터의 메모리 주소 등을 기록해 둔 태그를 달아 놓을 필요가 있다. 이러한 <strong>태그들의 묶음을 캐싱 라인</strong>이라고 하며, 메모리로부터 가져올 때에도 캐싱 라인을 기준으로 가져온다. 종류로는 대표적으로 세 가지 방식이 존재한다.</p>
<ol>
<li>Full Associative</li>
<li>Set Associative</li>
<li>Dircet Map</li>
</ol>
<h2 id="데이터베이스" style="position:relative;"><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4" aria-label="데이터베이스 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>데이터베이스</h2>
<h3 id="데이터베이스-개요" style="position:relative;"><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9C%EC%9A%94" aria-label="데이터베이스 개요 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>데이터베이스 개요</h3>
<h4 id="데이터베이스를-사용하는-이유" style="position:relative;"><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0" aria-label="데이터베이스를 사용하는 이유 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>데이터베이스를 사용하는 이유</h4>
<p>데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다(현재도 부분적으로 사용되고 있다.). 데이터를 각각의 파일 단위로 저장하며, 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다. 이 때의 문제점은 데이터 종속성 문제와 중복성, 데이터 무결성이다.</p>
<h4 id="데이터베이스의-특징" style="position:relative;"><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%ED%8A%B9%EC%A7%95" aria-label="데이터베이스의 특징 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>데이터베이스의 특징</h4>
<ol>
<li>데이터의 독립성
<ul>
<li>물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.</li>
<li>논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.</li>
</ul>
</li>
<li>데이터의 무결성<br>
여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로, 데이터의 유효성 검사를 통해 무결성을 구현하게 된다.</li>
<li>데이터의 보안성<br>
인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.</li>
<li>데이터의 일관성<br>
연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.</li>
<li>데이터 중복 최소화<br>
데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터 중복성 문제를 해결할 수 있다.</li>
</ol>
<h4 id="데이터베이스의-성능" style="position:relative;"><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%84%B1%EB%8A%A5" aria-label="데이터베이스의 성능 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>데이터베이스의 성능</h4>
<p>데이터베이스의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작된다. 디스크 I/O란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 이때 데이터를 읽는 데에 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.</p>
<p>그렇기 때문에 순차 I/O가 랜덤 I/O보다 빠를 수밖에 없다. 하지만 현실에서는 대부분의 I/O작업이 랜덤 I/O이다. 그렇다면 랜덤 I/O를 순차 I/O로 바꾸어서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.</p>
<h3 id="index" style="position:relative;"><a href="#index" aria-label="index permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Index</h3>
<h4 id="인덱스index란-무엇인가" style="position:relative;"><a href="#%EC%9D%B8%EB%8D%B1%EC%8A%A4index%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="인덱스index란 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>인덱스(Index)란 무엇인가?</h4>
<p>인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인이라고 할 수 있다. 이 비유를 그대로 가져와서 인덱스를 살펴본다면 데이터는 책의 내용이고, 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 될 것이다. DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.</p>
<p>DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는 데는 빠르지만, 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 결론적으로 DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건 절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.</p>
<h4 id="index-자료구조" style="position:relative;"><a href="#index-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0" aria-label="index 자료구조 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Index 자료구조</h4>
<p>그렇다면 DBMS는 인덱스를 어떻게 관리하고 있는가</p>
<h5>B+-Tree 인덱스 알고리즘</h5>
<p>일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다. B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리한다.), 원래의 값을 이용해 인덱싱 하는 알고리즘이다.</p>
<h5>Hash 인덱스 알고리즘</h5>
<p>칼럼의 값으로 해시 값을 계산해서 인덱싱 하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.</p>
<h5>왜 Index를 생성하는 데에 B-tree를 사용하는가?</h5>
<p>데이터에 접근하는 시간복잡도가 O(1)인 hash table이 더 효율적일 것 같은데? SELECT 질의어 조건에는 부등호(&#x3C;,>) 연산도 포함된다. hash table을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우 문제가 발생한다. 동등 연산(=)에 특화된 hash table은 데이터베이스의 자료구조로 적합하지 않다.</p>
<h4 id="clustered-index" style="position:relative;"><a href="#clustered-index" aria-label="clustered index permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Clustered Index</h4>
<p>클러스터(Cluster)란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 클러스터드 인덱스도 크게 다르지 않다. 인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것이다. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말한다.</p>
<p>클러스터드 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현한다. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다. 그렇기 때문에 프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야한다.</p>
<p>클러스터드 인덱스는 테이블 당 한 개만 생성할 수 있다. 프라이머리 키에 대해서만 적용되기 때문이다. 이에 반해 non 클러스터드 인덱스는 테이블 당 여러 개를 생성할 수 있다.</p>
<h4 id="primary-index-vs-secondary-index" style="position:relative;"><a href="#primary-index-vs-secondary-index" aria-label="primary index vs secondary index permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Primary Index vs Secondary Index</h4>
<p>파일 처리를 위해 인덱스를 만들었다면, 이 인덱스의 키로 어떤 것을 선택하느냐가 중요한 문제가 된다. 프라이머리 인덱싱(Primary Indexing)은 전역적으로 각 파일을 구별할 수 있는 유일한 키로 인덱스(Index)를 구성하는 방식이다. 이 방법은 데이터 추가, 삭제, 검색을 위해서 사용되는 쿼리가 프라이머리 키(Primary Key)로만 제한된다. 즉, 각각의 요청에 대해서 작업을 요청하는 쪽에서는 항상 이 프라이머리 키를 알고 있어야 하는 문제가 있다. 프라이머리 인덱싱은 매핑 함수(Mapping Function)가 필요하지 않으며, 직접 접근이 가능하다는 장점이 있다. 고정폭 길이 레코드 저장 방식을 택하고 있다면 이러한 인덱스 구성은 필요하지 않은데, 그것은 파일의 물리적인 위치를 간단한 매핑 함수만으로 구할 수 있기 때문이다. 하지만, 가변폭 길이 레코드 저장 방식의 경우, 이런 간단한 매핑 함수를 사용하여 파일의 물리적인 위치를 구할 수 없으며, Space Reclaiming과 같은 문제는 이 문제를 더욱 어렵게 한다. 따라서, 이와 같은 경우, 인덱스를 구성하는게 일반적이다.</p>
<p>이런 문제 때문에, 실제적으로는 세컨더리 인덱싱(Secondary Indexing)이 더 자주 쓰인다. 세컨더리 키(Secondary Key)는 프라이머리 키와는 달리 전역적으로 유일하게 각 파일을 구별할 수 없으며, 쿼리로 주어지는 키에 대해서 해당 데이터 중복이 발생한다. 세컨더리 인덱싱은 이렇게 중복되는 데이터를 구별하기 위해 프라이머리 키를 리스트와 같은 형식으로 추가적으로 가지고 있어야 하며, 요청된 데이터가 해당 데이터와 맞는지 확인해야 한다. 이와 같은 세컨더리 인덱싱을 역 인덱싱(Inverted Indexing)이라고도 한다.</p>
<p>프라이머리 키는 너무나 기본적인 정보이기 때문에 클라이언트가 직접 사용하기에는 적절하지 않을 수도 있으며, 세컨더리 키는 상대적으로 더 클라이언트 쪽에 가깝기 때문에 좀 더 쿼리에 적합하지만 데이터 중복 가능성이 있다. 세컨더리 인덱싱은 단일 인덱스를 가지는 프라이머리 인덱싱에 비해, 더 많은 테이블을 가지기 때문에 데이터 검색, 추가, 삭제가 일어날 때 더 많은 시간이 소모되며, 좀 더 많은 메모리가 필요하다. 이것은 프라이머리 인덱싱과 비교해봤을 때 세컨더리 인덱싱과의 트레이드-오프 관계가 된다.<br>
<a href="https://celdee.tistory.com/312">출처 : 날개의 기억</a></p>
<h4 id="composite-index" style="position:relative;"><a href="#composite-index" aria-label="composite index permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Composite Index</h4>
<p>인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title을 search 하는 경우, index를 생성한 효과를 볼 수 있지만 author만으로 search 하는 경우, index를 생성한 것이 소용이 없어진다. 따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.</p>
<h4 id="index의-성능과-고려해야할-사항" style="position:relative;"><a href="#index%EC%9D%98-%EC%84%B1%EB%8A%A5%EA%B3%BC-%EA%B3%A0%EB%A0%A4%ED%95%B4%EC%95%BC%ED%95%A0-%EC%82%AC%ED%95%AD" aria-label="index의 성능과 고려해야할 사항 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Index의 성능과 고려해야할 사항</h4>
<p>SELELCT 쿼리의 성능을 월등히 향상시키는 Index는 항상 좋은 것일까? 쿼리문의 성능을 향상시킨다는데, 모든 컬럼에 Index를 생성해두면 빨라지지 않을까? <strong>결론부터 말하자면 그렇지 않다.</strong> 우선 첫 번째 이유는 Index를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때에도 별도의 과정이 추가적으로 발생하게 된다. INSERT의 경우, Index에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따른다. DELETE의 경우 Index에 존재하는 값은 삭제하지 않고 사용 안 한다는 표시로 남게된다. 즉 row의 수는 그대로인 것이다. 이 작업이 반복되면 어떻게 될까?</p>
<p>실제 데이터는 10만 건인데, 데이터가 100만 건이 있는 결과를 낳을 수도 있다는 것이다. 이렇게 되면 Index는 더 이상 제 역할을 못하게 되는 것이다. UPDATE의 경우는 INSERT인 경우의 문제와 DELETE인 경우의 문제를 동시에 수반한다. 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문이다. 즉 변경 전 데이터는 삭제되지 않고 INSERT로 인한 split도 발생하게 된다.</p>
<p>하지만 더 중요한 것은 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것이다. 즉, 데이터의 형식에 따라 인덱스를 만들면 효율적인 데이터의 형식과 비효율적인 데이터의 형식이 각각 존재할 수 있다는 것이다. 어떤 경우에 그럴까?</p>
<p>이름, 나이, 성별 세 가지의 필드를 갖고 있는 테이블을 생각해보자. 이름은 온갖 경우의 수가 존재할 것이며 나이는 INT 타입을 갖을 것이고, 성별은 남, 녀 두 가지 경우에 대해서만 데이터가 존재할 것임을 쉽게 예측할 수 있다. 이 경우 어떤 컬럼에 대해서 인덱스를 생성하는 것이 효율적일까? 결론부터 말하자면 이름에 대해서만 인덱스를 생성하는 것이 효율적이다.</p>
<p>왜 성별이나 나이는 인덱스를 생성하면 비효율적일까? 10000개의 레코드에 해당하는 테이블에 대해서 2000개 단위로 성별에 인덱스를 생성했다고 가정하자. 값의 범위가 좁은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O가 발생하기 때문에 그만큼 비효율적인 것이다.</p>
<h3 id="정규화" style="position:relative;"><a href="#%EC%A0%95%EA%B7%9C%ED%99%94" aria-label="정규화 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정규화</h3>
<h4 id="정규화는-어떤-배경에서-생겨났는가" style="position:relative;"><a href="#%EC%A0%95%EA%B7%9C%ED%99%94%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%B0%B0%EA%B2%BD%EC%97%90%EC%84%9C-%EC%83%9D%EA%B2%A8%EB%82%AC%EB%8A%94%EA%B0%80" aria-label="정규화는 어떤 배경에서 생겨났는가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정규화는 어떤 배경에서 생겨났는가?</h4>
<p>한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다. 또 중복된 정보로 인해 <code class="language-text">갱신 이상</code>이 발생하게 된다. 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우, 어느 것이 정확한지 알수 없게 되는 것이다. 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다.</p>
<h5>갱신 이상에는 어떠한 것들이 있는가?</h5>
<ul>
<li>삽입 이상(insertion anomailes)<br>
원하지 않는 자료가 삽입된다든지, 삽입하는 데에 자료가 부족해서 삽입이 되지 않아 발생하는 문제점을 말한다.</li>
<li>삭제 이상(deletion anomailies)<br>
하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로써 원하지 않는 정보 손실이 발생하는 문제점을 말한다.</li>
<li>수정(갱신)이상(modification anomalies)<br>
정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점을 말한다.</li>
</ul>
<h4 id="그래서-정규화란-무엇인가" style="position:relative;"><a href="#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%A0%95%EA%B7%9C%ED%99%94%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="그래서 정규화란 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>그래서 정규화란 무엇인가?</h4>
<p>관계형 데이터베이스에서 중복을 최소화 하기 위해 데이터를 구조화하는 작업이다. 좀 더 구체적으로는 불만족스러운 나쁜 릴레이션의 애트리뷰트들을 나우어서 좋고 작은 릴레이션으로 분해하는 작업을 말한다. 정규화 과정을 거치게 되면 정규형을 만족하게 된다. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제1 정규형, 제2 정규형, 제3 정규형, ... 등이 존재한다.</p>
<h5>'나쁜' 릴레이션은 어떻게 파악하는가?</h5>
<p>엔티티를 구성하고 있는 애트리뷰트 간에 함수적 종속성(Functional Dependency)을 판단한다. 판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용된다. 즉, 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고, 그 정규형을 만족하지 못하는 정규형을 나쁜 릴레이션으로 파악한다.</p>
<h5>함수적 종속성이란 무엇인가?</h5>
<p>함수적 종속성이란 애트리뷰트  데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종이다. X와 Y를 임의의 애트리뷰트 집합이라고 할 때, X의 값이 Y의 값을 유일하게(unique) 결정한다면 'X는 Y를 함수적으로 결정한다"라고 한다. 함수적 종속성은 실세계에서 존재하는 애트리뷰트들 사이의 제약조건으로부터 유도된다. 또한 각종 추론 규칙에 따라서 애트리뷰트들 간의 함수적 종속성을 판단할 수 있다.<br>
<em>cf) 애트리뷰트들의 관계로부터 추론된 함수적 종속성들을 기반으로 추론 가능한 모든 함수적 종속성들의 집합을 폐포라고 한다.</em></p>
<h5>각각의 정규형은 어떠한 조건을 만족해야 하는가?</h5>
<ol>
<li>분해의 대상인 분해 집합 D는 <strong>무손실 조인</strong>을 보장해야 한다.</li>
<li>분해 집합 D는 함수적 종속성을 보존해야 한다.</li>
</ol>
<h4 id="제1-정규형" style="position:relative;"><a href="#%EC%A0%9C1-%EC%A0%95%EA%B7%9C%ED%98%95" aria-label="제1 정규형 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>제1 정규형</h4>
<p>애트리뷰트의 도메인이 오직 <code class="language-text">원자값</code>만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다. 즉, 복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등의 비 원자적인 애트리뷰트들을 허용하지 않는 릴레이션 형태를 말한다.</p>
<h4 id="제2-정규형" style="position:relative;"><a href="#%EC%A0%9C2-%EC%A0%95%EA%B7%9C%ED%98%95" aria-label="제2 정규형 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>제2 정규형</h4>
<p>모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 <strong>완전 함수적 종속</strong>이면 제2 정규형을 만족한다고 볼 수 있다. 완전 함수적 종속이란 <code class="language-text">X -&gt; Y</code>라고 가정했을 떄, X의 어떠한 애트리뷰트라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태를 말한다.</p>
<h4 id="제3-정규형" style="position:relative;"><a href="#%EC%A0%9C3-%EC%A0%95%EA%B7%9C%ED%98%95" aria-label="제3 정규형 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>제3 정규형</h4>
<p>어떠한 비주요 애트리뷰트도 기본키에 대해서 <strong>이행적으로 종속되지 않으면</strong> 제3 정규형을 만족한다고 볼 수 있다. 이행 함수적 종속이란 <code class="language-text">X -&gt; Y</code>, <code class="language-text">Y -&gt; Z</code>의 경우에 의해서 추론될 수 있는 <code class="language-text">X -&gt; Y</code>의 종속 관계를 말한다. 즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.</p>
<h4 id="bcnfboyce-codd정규형" style="position:relative;"><a href="#bcnfboyce-codd%EC%A0%95%EA%B7%9C%ED%98%95" aria-label="bcnfboyce codd정규형 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BCNF(Boyce-codd)정규형</h4>
<p>여러 후보키가 존재하는 릴레이션에 해당하는 정규화 내용이다. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제3 정규형을 보완하는 데에 의미가 있다. 비주요 애트리뷰트가 후보키의 일부를 경절하며 분해하는 과정을 말한다.</p>
<p><em>각 정규형은 그의 선행 정규형보다 더 엄격한 조건을 갖는다.</em></p>
<ul>
<li>모든 제2 정규형 릴레이션은 제1 정규형을 갖는다.</li>
<li>모든 제3 정규형 릴레이션은 제2 정규형을 갖는다.</li>
<li>모든 BCNF 정규형 릴레이션은 제3 정규형을 갖는다.</li>
</ul>
<p>수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게하는 것이다.</p>
<h4 id="정규화에는-어떠한-장점이-있는가" style="position:relative;"><a href="#%EC%A0%95%EA%B7%9C%ED%99%94%EC%97%90%EB%8A%94-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%9E%A5%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80" aria-label="정규화에는 어떠한 장점이 있는가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정규화에는 어떠한 장점이 있는가?</h4>
<ol>
<li>데이터베이스 변경시 이상현상(Anomaly) 제거<br>
위에서 언급했던 각종 이상 현상들이 발생하는 문제점을 해결할 수 있다.</li>
<li>데이터 베이스 구조 확장 시 재 디자인 최소화<br>
정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장을 할 시에 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되며 응용프로그램의 생명을 연장시킨다.</li>
<li>사용자에게 데이터 모델을 더욱 의미있게 제공<br>
정규화된 테이블들과 정규화된 테이블들 간의 관계들은 현실 세계에서의 개념들과 그들관에 관계들을 반영한다.</li>
</ol>
<h4 id="단점은-없는가" style="position:relative;"><a href="#%EB%8B%A8%EC%A0%90%EC%9D%80-%EC%97%86%EB%8A%94%EA%B0%80" aria-label="단점은 없는가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>단점은 없는가?</h4>
<p>릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN연산)이 많아진다. 이로 인해 질의에 대한 응답 시간이 느려질 수 있다. 조금 덧붙이자면, 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여금 삽입/ 삭제/ 갱신 이상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있다는 특성이 있다.</p>
<h4 id="단점에서-미루어-보았을-때-어떠한-상황에서-정규화를-진행해야-하는가-단점에-대한-대응책은" style="position:relative;"><a href="#%EB%8B%A8%EC%A0%90%EC%97%90%EC%84%9C-%EB%AF%B8%EB%A3%A8%EC%96%B4-%EB%B3%B4%EC%95%98%EC%9D%84-%EB%95%8C-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%83%81%ED%99%A9%EC%97%90%EC%84%9C-%EC%A0%95%EA%B7%9C%ED%99%94%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80-%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8C%80%EC%9D%91%EC%B1%85%EC%9D%80" aria-label="단점에서 미루어 보았을 때 어떠한 상황에서 정규화를 진행해야 하는가 단점에 대한 대응책은 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>단점에서 미루어 보았을 때 어떠한 상황에서 정규화를 진행해야 하는가? 단점에 대한 대응책은?</h4>
<p>조회를 하는 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우에 반정규화를 하는 전략이 필요하다.</p>
<h5>반정규화(De-normalzation, 비정규화)</h5>
<p><code class="language-text">반정규화</code>는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다. 디스크 I/O 양이 많아서 조회 시에 성능이 저하되거나, 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다. 일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부준적으로 반정규화를 고려하게 된다.</p>
<h5>무엇이 반정규화의 대상이 되는가?</h5>
<ol>
<li>자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우</li>
<li>테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우</li>
<li>테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우</li>
</ol>
<h5>반정규화 과정에서 주의할 점은?</h5>
<p>반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다. 또한 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.</p>
<h3 id="transaction" style="position:relative;"><a href="#transaction" aria-label="transaction permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transaction</h3>
<h4 id="트랜잭션이란-무엇인가" style="position:relative;"><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" aria-label="트랜잭션이란 무엇인가 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>트랜잭션이란 무엇인가?</h4>
<p>트랜잭션은 작업의 <strong>완전성</strong>을 보장해주는 것이다. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하게 하거나, 혹여 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다. 사용자의 입장에서는 작업의 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.</p>
<h4 id="트랜잭션과-lock" style="position:relative;"><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-lock" aria-label="트랜잭션과 lock permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>트랜잭션과 Lock</h4>
<p>잠금과 트랜잭션은 서로 비슷한 개념같지만 사실 잠근은 동시성을 제어하기 위한 기능이고, 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우, 한 시점에 하나의 커넥션만 순서대로 변경할 수 있게 해주는 역할을 한다. 여기서 자원은 레코드나 테이블을 말한다. 이와는 조금 다르게 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미가 있는 개념은 아니다. 트랜잭션은 하나의 논리적인 작업 셋 안에, 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다. 예를 들면 HW에러 또는 SW에러와 같은 문제로 인해 작업에 실패가 있을 경우, 특별한 대책이 필요하게 되는데 이러한 문제를 해결하는 것이다.</p>
<h4 id="트랜잭션의-특성" style="position:relative;"><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%ED%8A%B9%EC%84%B1" aria-label="트랜잭션의 특성 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>트랜잭션의 특성</h4>
<p><em>트랜잭션은 어떠한 특성을 만족해야 할까? 트랜잭션은 다음의 ACID라는 4가지의 특성을 만족해야 한다.</em></p>
<h5>원자성(Atomicity)</h5>
<p>만약 트랜잭션 중간에 어떠한 문제가 발생한다면, 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며, 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.</p>
<h5>일관성(Consistency)</h5>
<p>트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.</p>
<h5>고립성(Isolation)</h5>
<p>각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.</p>
<h5>지속성(Durability)</h5>
<p>트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.</p>
<h4 id="트랜잭션의-상태" style="position:relative;"><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EC%83%81%ED%83%9C" aria-label="트랜잭션의 상태 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>트랜잭션의 상태</h4>
<p><img src="https://raw.githubusercontent.com/JaeYeopHan/Interview_Question_for_Beginner/master/Database/images/transaction-status.png" alt="image"></p>
<h5>Active</h5>
<p>트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.</p>
<h5>Partially Committed</h5>
<p>트랜잭션의 <code class="language-text">Commit</code> 명령이 도착한 상태. 트랜잭션의 <code class="language-text">commit</code> 이전에 <code class="language-text">sql</code>문이 수행되고, <code class="language-text">commit</code>만 남은 상태를 말한다.</p>
<h5>Failed</h5>
<p>트랜잭션 실패 상태. 트랜잭션이 더 이상 정상적으로 진행할 수 없는 상태를 말한다.</p>
<h5>Committed</h5>
<p>트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.</p>
<h5>Aborted</h5>
<p>트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션이 실행 이전 데이터로 돌아간 상태를 말한다.</p>
<h5>Partially Committed와 Committed의 차이점</h5>
<p><code class="language-text">commit</code> 요청이 들어오면 상태를 <code class="language-text">partially committed</code> 상태가 된다. 이후 <code class="language-text">commit</code>을 문제없이 수행할 수 있으면 <code class="language-text">committed</code> 상태로 전이되고, 만약 오류가 발생하면 <code class="language-text">failed</code> 상태가 된다. 즉, <code class="language-text">Partially Committed</code>는 <code class="language-text">Commit</code> 요청이 들어온 상태를 말하며, <code class="language-text">committed</code>는 <code class="language-text">commit</code>은 정상적으로 완료한 상태를 말한다.</p>
<h4 id="트랜잭션을-사용할-때-주의할-점" style="position:relative;"><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90" aria-label="트랜잭션을 사용할 때 주의할 점 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>트랜잭션을 사용할 때 주의할 점</h4>
<p>트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉, 트랜잭션의 범위를 최소화하라는 의미이다. 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.</p>
<h4 id="교착상태deadlock" style="position:relative;"><a href="#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9Cdeadlock" aria-label="교착상태deadlock permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>교착상태(DeadLock)</h4>
<h5>교착상태란 무엇인가</h5>
<p>복수의 트랜잭션을 사용하다보면 교착상태가 일어날 수 있다. 교착상태란 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 레코드)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를 교착상태라고 한다.</p>
<h5>교착상태의 예(MySQL)</h5>
<p>MySQL <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a>에 따른 특성때문에 트랜잭션에서 갱신 연산(INSERT, UPDATE, DELETE)를 실행하면 잠금을 획득한다.(기본은 행에 대한 잠금)
<img src="https://raw.githubusercontent.com/JaeYeopHan/Interview_Question_for_Beginner/master/Database/images/deadlock.png" alt="image"><br>
트랜잭션1이 테이블 B의 첫 번째 행의 잠금을 얻고 트랜잭션2도 테이블 A의 첫 번째 행의 잠금을 얻었다고 하자.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">Transaction</span> <span class="token number">1</span><span class="token operator">></span> <span class="token keyword">create</span> <span class="token keyword">table</span> B <span class="token punctuation">(</span>i1 <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">)</span> <span class="token keyword">engine</span> <span class="token operator">=</span> <span class="token keyword">innodb</span><span class="token punctuation">;</span>
<span class="token keyword">Transaction</span> <span class="token number">2</span><span class="token operator">></span> <span class="token keyword">create</span> <span class="token keyword">table</span> A <span class="token punctuation">(</span>i1 <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">)</span> <span class="token keyword">engine</span> <span class="token operator">=</span> <span class="token keyword">innodb</span><span class="token punctuation">;</span>

<span class="token keyword">Transaction</span> <span class="token number">1</span><span class="token operator">></span> <span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> B <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">Transaction</span> <span class="token number">2</span><span class="token operator">></span> <span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> A <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>트랜잭션을 commit하지 않은 체 서로의 첫 번째 행에 대한 잠금을 요청하면</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">Transaction</span> <span class="token number">1</span><span class="token operator">></span> <span class="token keyword">insert</span> <span class="token keyword">into</span> A <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">Transaction</span> <span class="token number">2</span><span class="token operator">></span> <span class="token keyword">insert</span> <span class="token keyword">into</span> B <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ERROR <span class="token number">1213</span> <span class="token punctuation">(</span><span class="token number">40001</span><span class="token punctuation">)</span>: Deadlock found <span class="token keyword">when</span> trying <span class="token keyword">to</span> get <span class="token keyword">lock</span><span class="token punctuation">;</span> try restarting <span class="token keyword">transaction</span></code></pre></div>
<p>DeadLock이 발생한다. 일반적인 DBMS는 교착상태를 독자적으로 검출하여 보고한다.</p>
<h5>교착 상태의 빈도를 낮추는 방법</h5>
<ul>
<li>트랜잭션을 자주 커밋한다.</li>
<li>정해진 순서로 테이블에 접근한다. 위에서는 트랜잭션1이 테이블 B -> A의 순으로 접근했고, 트랜잭션2는 테이블 A -> B의 순으로 접근했는데, 이렇게 하지말고 테이블 A -> B순으로 접근하게 통일하여 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.</li>
<li>읽기 잠금 획득(SELECT ~ FOR UPDATE)의 사용을 피한다.</li>
<li>한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다. 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.</li>
</ul>
<h3 id="statement-vs-preparedstatement" style="position:relative;"><a href="#statement-vs-preparedstatement" aria-label="statement vs preparedstatement permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Statement vs PreparedStatement</h3>
<p>우선 속도 면에서 <code class="language-text">PreparedStatement</code>가 빠르다고 알려져있다. 이유는 쿼리를 수행하기 전에 이미 쿼리가 컴파일 되어 있으며, 반복 수행의 경우 프리 컴파일된 쿼리를 통해 수행이 이뤄지기 때문이다.</p>
<p><code class="language-text">Statement</code>에는 보통 변수를 설정하고 바인딩하는 <code class="language-text">static sql</code>이 사용되고 <code class="language-text">PreparedStatement</code>에서는 쿼리 자체에 조건이 들어가는 <code class="language-text">dynamicsql</code>이 사용된다.  <code class="language-text">PreparedStatement</code>가 파싱 타임을 줄여주는 것은 분명하지만, <code class="language-text">dynamic sql</code>을 사용하는 데에 따르는 퍼포먼스 저하를 고려하지 않을 수 없다.</p>
<p>하지만 성능을 고려할 때 시간 부분에서 가장 큰 비중을 차지하는 것은 테이블에서 Record(행)을 가져오는 과정이고 SQL문을 파싱하는 시간은 이 시간의 10분의 1에 불과하다. 그렇기 때문에 <code class="language-text">SQL Injection</code> 등의 문제를 보완해주는 <code class="language-text">PreparedStatement</code>를 사용하는 것이 옳다.</p>
<h3 id="nosql" style="position:relative;"><a href="#nosql" aria-label="nosql permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NoSQL</h3>
<h4 id="정의" style="position:relative;"><a href="#%EC%A0%95%EC%9D%98" aria-label="정의 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정의</h4>
<p>관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는 데에 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.</p>
<p>종류마다 쓰기/읽기 성능 특화, 2차 인덱스 지원, 오토 샤딩 지원같은 고유한 특징을 가진다. 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용한다. 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위하여 데이터 복제 등의 방법으로 관계형 데이터베이스가 제공하지 못하는 성능과 특징을 제공한다.</p>
<h4 id="cap이론" style="position:relative;"><a href="#cap%EC%9D%B4%EB%A1%A0" aria-label="cap이론 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CAP이론</h4>
<h5>일관성(Consistency)</h5>
<p>일관성은 동시성 또는 동일성이라고도 하며, 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의마한다. 이것은 관계형 데이터베이스가 지원하는 가장 기본적인 기능이지만, 일관성을 지원하지 않는 NoSQL을 사용한다면 데이터의 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있다. 느슨하게 처리된다는 것은 데이터의 변경을 시간의 흐름에 따라 여러 노드에 전파하는 것을 말한다. 이러한 방법을 최종적으로 일관성이 유지된다고 하여, 최종 일관성 또는 궁극적 일관성을 지원한다고 한다.</p>
<p>각 NoSQL들은 분산 노드 간의 데이터 동기화를 위해서 두 가지 방법을 사용한다. 첫 번째로 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법이 있다. 그만큼 느린 응답시간을 보이지만 데이터의 정합성을 보장한다. 두 번째로는 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법이 있다. 빠른 응답시간을 보인다는 장점이 있지만, 쓰기 노드에 장애가 발생했을 경우 데이터가 손실될 수있다.</p>
<h5>가용성(Availability)</h5>
<p>가용성이란 모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것이며, 내고장성이라고도 한다. 내고장성을 가진 NoSQL은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능하다.</p>
<p>몇몇 NoSQL은 가용성을 보장하기 위해 데이터 복제(Replication)을 사용한다. 동일한 데이터를 다중 노드에 중복 저장하여 그 중 몇 대의 노드가 고장나도 데이터가 유실되지 않도록 하는 방법이다. 데이터 중복 저장 방법에는 동일한 데이터를 가진 저장소를 하나 더 생성하는 Master-Slave 복제 방법과 데이터 단위로 중복 저장하는 Peer-to-Peer 복제 방법이 있다.</p>
<h5>네트워크 분할 허용성(Partition tolerance)</h5>
<p>분할 허용성이란 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함을 의미한다.</p>
<h4 id="저장-방식에-따른-nosql분류" style="position:relative;"><a href="#%EC%A0%80%EC%9E%A5-%EB%B0%A9%EC%8B%9D%EC%97%90-%EB%94%B0%EB%A5%B8-nosql%EB%B6%84%EB%A5%98" aria-label="저장 방식에 따른 nosql분류 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>저장 방식에 따른 NoSQL분류</h4>
<p><em><code class="language-text">Key-Value Model</code>, <code class="language-text">Document Model</code>, <code class="language-text">Column Model</code>, <code class="language-text">Graph Model</code>로 분류할 수 있다.</em></p>
<h5>Key-Value Model</h5>
<p>가장 기본적인 형태의 NoSQL이며, 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 갖는다. 단순한 저장구조로 인하여 복잡한 조회 연산을 지원하지 않는다. 또한, 고속 읽기와 쓰기에 최적화된 경우가 많다. 사용자의 프로필 정보, 웹 서버 클러스터를 위한 세션 정보, 장바구니 정보, URL 단축 정보 저장 등에 사용한다. 하나의 서비스 요청에 다수의 데이터 조희 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 없다. <em>e.g.)Redis</em></p>
<h5>Document Model</h5>
<p>키-값 모델을 개념적으로 확장한 구조로, 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다. 논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사하다. 키는 문서에 대한 ID로 표현된다. 또한 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID에 대한 인덱스를 생성한다. 문서 ID에 대한 인덱스를 사용하여 O(1)시간 안에 문서를 조회할 수 있다.</p>
<p>대부분의 Document Model NoSQL은 B트리 인덱스를 사용하여 2차 인덱스를 생성한다. B트리는 크기가 커지면 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 떨어지게 된다. 그렇기 때문에 읽기와 쓰기의 비율이 7:3 정도일 때 가장 좋은 성능을 보인다. 중앙 집중식 로그 저장, 타임 라인 저장, 통계 정보 저장 등에 사용된다. <em>ex)MongoDB</em></p>
<h5>Column Model</h5>
<p>하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다.</p>
<p>구글의 빅테이블이 대표적인 예로, 차후 컬럼형 NoSQL은 빅테이블의 영향을 받았다. 이러한 이유로 Row key, Column Key, Column Family와 같은 빅테이블 개념이 공통적으로 사용된다. 저장의 기본 단위는 컬럼으로, 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 이러한 컬럼들의 집합이 행(Row)이며, 행 키(Row Key)는 각 로우를 유일하게 식별하는 값이다. 이러한 로우들의 집합은 키 스페이스(Key Space)가 된다.</p>
<p>대부분의 컬럼 모델 NoSQL은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다. 데이터를 먼저 커밋로그와 메모리에 저장한 후에 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다. 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.</p>
<h1 id="2-javascript" style="position:relative;"><a href="#2-javascript" aria-label="2 javascript permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. JavaScript</h1>
<h2 id="js-event-loop" style="position:relative;"><a href="#js-event-loop" aria-label="js event loop permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JS Event Loop</h2>
<ul>
<li><a href="https://asfirstalways.tistory.com/362">JavaScript 이벤트 루프에 대해서</a></li>
<li><a href="http://sculove.github.io/blog/2018/01/18/javascriptflow/">자바스크립트의 비동기 처리 과정</a></li>
</ul>
<h2 id="hoisting" style="position:relative;"><a href="#hoisting" aria-label="hoisting permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hoisting</h2>
<p><em>Javascript라는 언어의 특성을 가장 잘 보여주는 특성 중 하나지만, ES6 문법이 표준화되면서 크게 문제가 되지 않게 되었다.</em></p>
<h3 id="정의-1" style="position:relative;"><a href="#%EC%A0%95%EC%9D%98-1" aria-label="정의 1 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정의</h3>
<p><code class="language-text">hoist</code>라는 단어의 사전적 정의는 끌어올리기 라는 뜻이다. 자바스크립트에서 끌어올려지는 것은 변수이다. <code class="language-text">var</code> keyword로 선언된 모든 변수 선언은 호이스트된다. 호이스트란 변수의 정의가 그 범위에 따라 <code class="language-text">선언</code>과 <code class="language-text">할당</code>으로 분리되는 것을 의미한다. 즉, 변수가 함수 내에서 정의되었을 경우, 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우, 전역 컨텍스트의 최상위로 변경이된다.</p>
<p>우선, 선언(Declaration)과 할당(Assignment)을 이해해야 한다. 끌어올려지는 것은 선언이다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span><span class="token number">100</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">//100</span>
<span class="token punctuation">}</span>
<span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>
<p>다른 언어의 경우엔, 변수 x를 선언하지 않고 출력하려 한다면 오류를 발생시킬 것이다. 하지만 자바스크립트에서는 <code class="language-text">undefined</code>라고 하고 넘어간다. <code class="language-text">var x = 100</code> 이 구문에서 <code class="language-text">var x</code>를 호이스트하기 때문이다. 즉, 작동 순서에 맞게 코드를 재구성하면 다음과 같다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> x
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span><span class="token number">100</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">//100</span>
<span class="token punctuation">}</span>
<span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>
<p>선언문은 항시 자바스크립트 엔진 구동 시에 가장 최우선으로 해석하므로 호이스팅되고, <code class="language-text">할당 구문은 런타임 과정에서 이루어지기 때문에</code> 호이스팅되지 않는다.</p>
<p>함수가 자신이 위치한 코드에 상관없이 함수 선언문 형태로 정의한 함수의 유호 범위는 전체 코드의 맨 처음부터 시작한다. 함수 선언이 함수 실행 부분보다 뒤에 있더라도 자바스크립트 엔진이 함수 선언을 끌어올리는 것을 의미한다. 함수 호이스팅은 함수를 끌어올리지만 변수의 값을 끌어올리지 않는다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// console > hello</span></code></pre></div>
<p>foo 함수에 대한 선언을 호이스팅하여 global 객체에 등록시키기 때문에 hello가 제대로 출력된다</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// console > Uncaught TypeError: foo is not a functiuon</span></code></pre></div>
<p>두 번째 예제의 함수 표현은 함수 리터럴을 할당하는 구조이기 때문에 호이스팅되지 않으며 그렇기 때문에 런타임환경에서 <code class="language-text">Type Error</code>을 발생시킨다.</p>
<h2 id="closure" style="position:relative;"><a href="#closure" aria-label="closure permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Closure</h2>
<p>Closure(클로저)는 두 개의 함수로 구성된 환경에서 이루어진 특별한 객체의 한 종류이다. 여기서 환경이라 함은 클로저가 생성될 때 그 범위에 있던, 여러 지역 변수들이 포함된 <code class="language-text">context</code>를 말한다. 이 클로저를 통해서 자바스크립트에는 없는 비공개(Private) 속성/메소드, 공개 속성/메소드를 구현할 수 있는 방안을 마련할 수 있다.</p>
<h3 id="클로저-생성하기" style="position:relative;"><a href="#%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0" aria-label="클로저 생성하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>클로저 생성하기</h3>
<p>다음은 클로저가 생성되는 조건이다.</p>
<ol>
<li>내부 함수가 익명 함수로 되어 외부 함수의 반환값으로 사용된다.</li>
<li>내부 함수는 외부 함수의 실행 환경(execution envirionment)에서 실행된다.</li>
<li>내부 함수에서 사용되는 변수 X는 외부 함수의 변수 스코프에 있다.</li>
</ol>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">closure</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// console> closure</span></code></pre></div>
<p><code class="language-text">outer</code>함수를 실행시키는 <code class="language-text">context</code>에는 <code class="language-text">name</code>이라는 변수가 존재하지 않는다는 것을 확인할 수 있다. 비슷한 맥락에서 코드를 조금 변경해볼 수 있다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Warning</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">closure</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> callFunc <span class="token operator">=</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">callFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// console> closure</span></code></pre></div>
<p>위 코드에서 <code class="language-text">callFunc</code>를 클로저라고 한다. <code class="language-text">callFunc</code> 호출에 의해 <code class="language-text">name</code>이라는 값이 console에 찍히는데, 찍히는 값은 <code class="language-text">warning</code>이 아니라 <code class="language-text">closure</code>이라는 값이다. 즉, <code class="language-text">outer</code> 함수의 <code class="language-text">context</code>에 속해있는 변수를 참조하라는 것이다. 여기서 <code class="language-text">outer</code>함수의 지역변수로 존재하는 <code class="language-text">name</code> 변수를 <code class="language-text">free variable(자유 변수)</code>라고 한다.</p>
<p>이처럼 외부 함수 호출이 종료되더라도 외부 함수의 지역 변수 및 변수 스코프 객체의 체인 관계를 유지할 수 있는 구조를 클로저라고 한다. 보다 정확히는 외부 함수에 의해 반환되는 내부 함수를 가리키는 말이다.</p>
<h2 id="what-is-this" style="position:relative;"><a href="#what-is-this" aria-label="what is this permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>what is 'this'</h2>
<p>자바스크립트에서 모든 함수는 실행될 때마다 함수 내부에 <code class="language-text">this</code>라는 객체가 추가된다. <code class="language-text">argument</code>라는 유사 배열 객체와 함께, 함수 내부로 암묵적으로 전달되는 것이다. 그렇기 때문에 자바스크립트에서의 <code class="language-text">this</code>는 함수가 호출된 상황에 따라 그 모습을 달리한다.</p>
<h3 id="상황-1-객체의-메소드를-호출할-때" style="position:relative;"><a href="#%EC%83%81%ED%99%A9-1-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%A0-%EB%95%8C" aria-label="상황 1 객체의 메소드를 호출할 때 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상황 1. 객체의 메소드를 호출할 때</h3>
<p><code class="language-text">객체의 포르퍼티가 함수일 경우</code> 메소드라고 부른다. <code class="language-text">this</code>는 함수를 실행할 때 함수를 소유하고 있는 객체(메소드를 포함하고 있는 인스턴스)를 참조한다. 즉, 해당 메소드를 호출한 객체로 바인딩된다. <code class="language-text">A.B</code>일 때, <code class="language-text">B</code>함수 내부에서의 <code class="language-text">this</code>는 <code class="language-text">A</code>를 가리키는 것이다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">"foo"</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// console> Object {name: "foo", sayName: sayName()}</span></code></pre></div>
<h3 id="상황-2-함수를-호출할-때" style="position:relative;"><a href="#%EC%83%81%ED%99%A9-2-%ED%95%A8%EC%88%98%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%A0-%EB%95%8C" aria-label="상황 2 함수를 호출할 때 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상황 2. 함수를 호출할 때</h3>
<p>특정 객체의 메소드가 아니라 함수를 호출하면, 해당 함수 내부 코드에서 사용된 <code class="language-text">this</code>는 전역객체에 바인딩된다. <code class="language-text">A.B</code>일 때, <code class="language-text">A</code>가 전역 객체가 되므로 <code class="language-text">B</code>함수 내부에서의 <code class="language-text">this</code>는 당연히 전역 객체에 바인딩되는 것이다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">func1</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">func1's this.value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">func2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">func2's this.value </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

myObj<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// console> func1's this.value: 1</span>
<span class="token comment">// console> func2's this.value: 100</span></code></pre></div>
<h3 id="상황-3-생성자-함수를-통해-객체를-생성할-때" style="position:relative;"><a href="#%EC%83%81%ED%99%A9-3-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%B4-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%A0-%EB%95%8C" aria-label="상황 3 생성자 함수를 통해 객체를 생성할 때 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상황 3. 생성자 함수를 통해 객체를 생성할 때</h3>
<p>그냥 함수를 호출하는 것이 아니라 <code class="language-text">new</code> 키워드를 통해 생성자 함수를 호출할 때는 또 <code class="language-text">this</code>가 다르게 바인딩된다. <code class="language-text">new</code> 키워드를 통해서 호출된 함수 내부에서의 <code class="language-text">this</code>는 객체 자신이 된다. 생성자 함수를 호출할 때의 <code class="language-text">this</code> 바인딩은 생성자 함수가 동작하는 방식을 통해 이해할 수 있다.</p>
<p><code class="language-text">new</code>연산자를 통해 함수를 생성자로 호출하게 되면, 일단 빈 객체가 생성되고 <code class="language-text">this</code>가 바인딩된다. 이 객체는 함수를 통해 생성된 객체이며, 자신의 부모인 프로토타입 객체와 연결되어 있다. 그리고 return문이 명시되어 있지 않은 경우에는 <code class="language-text">this</code>로 바인딩된 새로 생성한 객체가 리턴된다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Person</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span></code></pre></div>
<h3 id="상황-4-apply-call-bind를-통한-호출" style="position:relative;"><a href="#%EC%83%81%ED%99%A9-4-apply-call-bind%EB%A5%BC-%ED%86%B5%ED%95%9C-%ED%98%B8%EC%B6%9C" aria-label="상황 4 apply call bind를 통한 호출 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상황 4. apply, call, bind를 통한 호출</h3>
<p>상황 1, 상황 2, 상황 3에 의존하지 않고 <code class="language-text">this</code>를 자바스크립트 코드로 주입 또는 설정할 수 있는 방법이다. 상황 2에서 사용했던 예제 코드를 다시 한 번 살펴보자. <code class="language-text">func2</code>를 호출할 때, <code class="language-text">func1</code>에서의 <code class="language-text">this</code>를 주입하기 위해서 위 세 가지 메소드를 사용할 수 있다. 그리고 세 메소드의 차이점을 파악하기 위해 <code class="language-text">func2</code>에 파라미터를 받을 수 있도록 수정한다.</p>
<h4 id="code-classlanguage-textbindcode-메소드-사용" style="position:relative;"><a href="#code-classlanguage-textbindcode-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%82%AC%EC%9A%A9" aria-label="code classlanguage textbindcode 메소드 사용 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">bind</code> 메소드 사용</h4>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">func1</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">func1's this.value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">func2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val1<span class="token punctuation">,</span> val2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">func2's this.value </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val2<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">param1</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">param2</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

myObj<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// console> func1's this.value: 1</span>
<span class="token comment">// console> func2's this.value: 1 and param1 and param2</span></code></pre></div>
<h4 id="code-classlanguage-textcallcode-메소드-사용" style="position:relative;"><a href="#code-classlanguage-textcallcode-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%82%AC%EC%9A%A9" aria-label="code classlanguage textcallcode 메소드 사용 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">call</code> 메소드 사용</h4>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">func1</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">func1's this.value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">func2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val1<span class="token punctuation">,</span> val2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">func2's this.value </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val2<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">func2</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">param1</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">param2</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

myObj<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// console> func1's this.value: 1</span>
<span class="token comment">// console> func2's this.value: 1 and param1 and param2</span></code></pre></div>
<h4 id="code-classlanguage-textapplycode-메소드-사용" style="position:relative;"><a href="#code-classlanguage-textapplycode-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%82%AC%EC%9A%A9" aria-label="code classlanguage textapplycode 메소드 사용 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">apply</code> 메소드 사용</h4>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">func1</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">func1's this.value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">func2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val1<span class="token punctuation">,</span> val2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">func2's this.value </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val2<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">func2</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">param1</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">param2</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

myObj<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// console> func1's this.value: 1</span>
<span class="token comment">// console> func2's this.value: 1 and param1 and param2</span></code></pre></div>
<h4 id="code-classlanguage-textbindcode-vs-code-classlanguage-textapplycode-code-classlanguage-textcallcode" style="position:relative;"><a href="#code-classlanguage-textbindcode-vs-code-classlanguage-textapplycode-code-classlanguage-textcallcode" aria-label="code classlanguage textbindcode vs code classlanguage textapplycode code classlanguage textcallcode permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">bind</code> vs <code class="language-text">apply</code>, <code class="language-text">call</code></h4>
<p>우선 <code class="language-text">bind</code>는 함수를 선언할 때, <code class="language-text">this</code>와 파라미터를 지정해줄 수 있으며, <code class="language-text">call</code>과 <code class="language-text">apply</code>는 함수를 호출할 때 <code class="language-text">this</code>와 파라미터를 지정해준다.</p>
<h4 id="code-classlanguage-textapplycode-vs-bind-code-classlanguage-textcallcode" style="position:relative;"><a href="#code-classlanguage-textapplycode-vs-bind-code-classlanguage-textcallcode" aria-label="code classlanguage textapplycode vs bind code classlanguage textcallcode permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">apply</code> vs bind, <code class="language-text">call</code></h4>
<p><code class="language-text">apply</code> 메소드에는 첫 번째 인자로 <code class="language-text">this</code>를 넘겨주고, 두 번째 인자로 넘겨줘야하는 파라미터를 배열의 형태로 전달한다. <code class="language-text">bind</code> 메소드와 <code class="language-text">call</code> 메소드는 각각의 파라미터를 하나씩 넘겨주는 형태이다.</p>
<h2 id="promise" style="position:relative;"><a href="#promise" aria-label="promise permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise</h2>
<p>Javascript에서는 대부분의 작업들이 비동기로 이러우진다. 콜백 함수로 처리하면 되는 문제였지만, 요즘에는 프론트엔드의 규모가 커지면서 코드의 복잡도가 높아지는 상황이 발생하였다. 이러면서 콜백이 중첩되는 경우가 따라서 발생하였고, 이를 해결할 방안으로 등장한 것이 <code class="language-text">Promise</code> 패턴이다. <code class="language-text">Promise</code> 패턴을 사용하면 비동기 작업들을 순차적으로 진행하거나, 병렬로 진행하는 등의 컨트롤이 보다 수월해진다. 또한 예외처리에 대한 구조가 존재하기 때문에 오류 처리 등에 대해 보다 가시적으로 관리할 수 있다. 이 <code class="language-text">Promise</code> 패턴은 ECMAScript6 스펙에 정식으로 포함되었다.</p>
<h3 id="reference" style="position:relative;"><a href="#reference" aria-label="reference permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reference</h3>
<ul>
<li><a href="http://programmingsummaries.tistory.com/325">http://programmingsummaries.tistory.com/325</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></li>
<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises?hl=ko">https://developers.google.com/web/fundamentals/getting-started/primers/promises?hl=ko</a></li>
<li><a href="https://jaeyeophan.github.io/categories/ECMAScript6/">ECMAScript6 학습하기</a></li>
</ul>
<h2 id="asyncawait" style="position:relative;"><a href="#asyncawait" aria-label="asyncawait permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Async/Await</h2>
<p>비동기 코드를 작성하는 새로운 방법이다. JS 개발자들은 훌룡한 비동기 처리 방안인 Promise로 만족하지 못하고 더 훌룡한 방법을 고안해 낸 것이다. 절차적 언어에서 작성하는 코드와 같이 사용법도 간단하고 이해하기도 쉽다. function 키워드 앞에 Async를 붙여주고, function 내부의 promise를 반환하는 비동기 처리 함수 앞에 await을 붙여주기만 하면 된다. async/await의 가장 큰 장점은 promise보다 비동기 코드의 겉모습을 더 깔끔하게 한다는 것이다. 이것은 ES8의 공식 스펙이며, node8LTS에서 지원된다.</p>
<ul>
<li><code class="language-text">Promise</code> 구현</li>
</ul>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>needMoreRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">makeMoreRequest</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
                  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">moreData</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
                      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>moreData<span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token keyword">return</span> moreData<span class="token punctuation">;</span>
                  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
                      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Error while makeMoreRequest'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> data<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Error while getData'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<ul>
<li><code class="language-text">Async/Await</code> 구현</li>
</ul>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>needMoreRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> moreData <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">makeMoreRequest</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>moreData<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> moreData<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> data<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Error while getData'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h3 id="reference-1" style="position:relative;"><a href="#reference-1" aria-label="reference 1 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reference</h3>
<ul>
<li><a href="https://medium.com/@kiwanjung/%EB%B2%88%EC%97%AD-async-await-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90-promise%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-955dbac2c4a4">https://medium.com/@kiwanjung/%EB%B2%88%EC%97%AD-async-await-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90-promise%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-955dbac2c4a4</a></li>
<li><a href="https://medium.com/@constell99/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-async-await-%EA%B0%80-promises%EB%A5%BC-%EC%82%AC%EB%9D%BC%EC%A7%80%EA%B2%8C-%EB%A7%8C%EB%93%A4-%EC%88%98-%EC%9E%88%EB%8A%94-6%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%9C%A0-c5fe0add656c">https://medium.com/@constell99/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-async-await-%EA%B0%80-promises%EB%A5%BC-%EC%82%AC%EB%9D%BC%EC%A7%80%EA%B2%8C-%EB%A7%8C%EB%93%A4-%EC%88%98-%EC%9E%88%EB%8A%94-6%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%9C%A0-c5fe0add656c</a></li>
</ul>
<h2 id="arrow-function" style="position:relative;"><a href="#arrow-function" aria-label="arrow function permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arrow Function</h2>
<p>화살표 함수 표현식은 기존의 function 표현방식보다 간결하게 함수를 표현할 수 없다. 화살표 함수는 항상 익명이며, 자신의 <code class="language-text">this</code>, <code class="language-text">arguments</code>, <code class="language-text">super</code>, 그리고 <code class="language-text">new.target</code>을 바인딩하지 않는다. 그래서 생성자로는 사용할 수 없다.</p>
<ul>
<li>화살표 함수 도입 영향 : 짧은 함수, 상위 스코프 <code class="language-text">this</code></li>
</ul>
<h3 id="짧은-함수" style="position:relative;"><a href="#%EC%A7%A7%EC%9D%80-%ED%95%A8%EC%88%98" aria-label="짧은 함수 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>짧은 함수</h3>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> materials <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'Hydrogen'</span><span class="token punctuation">,</span>
  <span class="token string">'Helium'</span><span class="token punctuation">,</span>
  <span class="token string">'Lithium'</span><span class="token punctuation">,</span>
  <span class="token string">'Beryllium'</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

materials<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">material</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> material<span class="token punctuation">.</span>length<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [8, 6, 7, 9]</span>

materials<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">material</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> material<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [8, 6, 7, 9]</span>

materials<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>length<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [8, 6, 7, 9]</span></code></pre></div>
<p>기존의 function을 생략 후 => 로 대체 표현</p>
<h3 id="상위-스코프-this" style="position:relative;"><a href="#%EC%83%81%EC%9C%84-%EC%8A%A4%EC%BD%94%ED%94%84-this" aria-label="상위 스코프 this permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상위 스코프 this</h3>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// |this|는 person 객체를 참조</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>일반 함수에서 this는 자기 자신을 this로 정의한다. 하지만 화살표 함수 this는 Person의 this와 동일한 값을 갖는다. setInterval로 전달된 this는 Person의 this를 가리키며, Person 객체의 age에 접근한다.</p>
<h3 id="reference-2" style="position:relative;"><a href="#reference-2" aria-label="reference 2 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reference</h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></li>
</ul>
<h1 id="3-frontend" style="position:relative;"><a href="#3-frontend" aria-label="3 frontend permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. FrontEnd</h1>
<h2 id="브라우저의-작동-원리" style="position:relative;"><a href="#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC" aria-label="브라우저의 작동 원리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>브라우저의 작동 원리</h2>
<h2 id="document-object-model" style="position:relative;"><a href="#document-object-model" aria-label="document object model permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Document Object Model</h2>
<h3 id="event-bubbling-and-capturing" style="position:relative;"><a href="#event-bubbling-and-capturing" aria-label="event bubbling and capturing permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Event Bubbling and Capturing</h3>
<h3 id="event-delegation" style="position:relative;"><a href="#event-delegation" aria-label="event delegation permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Event Delegation</h3>
<h2 id="cors" style="position:relative;"><a href="#cors" aria-label="cors permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CORS</h2>
<h2 id="ajax" style="position:relative;"><a href="#ajax" aria-label="ajax permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AJAX</h2>
<h2 id="웹-성능-관련된-issues" style="position:relative;"><a href="#%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EA%B4%80%EB%A0%A8%EB%90%9C-issues" aria-label="웹 성능 관련된 issues permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>웹 성능 관련된 Issues</h2>
<h2 id="서버-사이드-렌더링-vs-클라이언트-사이드-렌더링" style="position:relative;"><a href="#%EC%84%9C%EB%B2%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81-vs-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81" aria-label="서버 사이드 렌더링 vs 클라이언트 사이드 렌더링 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>서버 사이드 렌더링 vs 클라이언트 사이드 렌더링</h2>
<h2 id="css-methodology" style="position:relative;"><a href="#css-methodology" aria-label="css methodology permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS Methodology</h2>
<h2 id="normalizecss-vs-reactcss" style="position:relative;"><a href="#normalizecss-vs-reactcss" aria-label="normalizecss vs reactcss permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Normalize.css vs React.css</h2>
<h2 id="그-외-프론트엔드-개발-환경-관련" style="position:relative;"><a href="#%EA%B7%B8-%EC%99%B8-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B4%80%EB%A0%A8" aria-label="그 외 프론트엔드 개발 환경 관련 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>그 외 프론트엔드 개발 환경 관련</h2>
<h2 id="추가자료들" style="position:relative;"><a href="#%EC%B6%94%EA%B0%80%EC%9E%90%EB%A3%8C%EB%93%A4" aria-label="추가자료들 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>추가자료들</h2>
<!-- 
 ## 알고리즘
 # 면접
https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C
## 중요한 면접 질문
- 규모가 작을수록 리액트 등의 프레임워크에 대한 것을 물었고, 규모가 클 수록 자바스크립트나 웹브라우저같은 깊은 내용을 물었다.
- 리액트 관련된 것을 물을 땐 virtual-DOM에 관한 건 꼭 물었고, 렌더링 최적화 관련해서 useMemo나 useCallback등 사용해서 최적화 하는 게 어떤 건지, re-rendering되는 게 어떤 건지 물었다.

### 자바스크립트 관련
- 자바스크립트 실행컨텍스트에 관한 건 반드시 물어본다.
- this가 결정되는 것에 대해 묻고
- 클로저에 관해서는 반드시 물어본다.
- 이벤트루프에 관해서도 거의 물어본다. Event Bubbling, Capturing Delegation에 관해서도 많이 묻는다.
- promise객체에 관해 묻고, Async Await 예외처리에 까다로운 점에 대해 묻는다
- 자바스크립트 원시값이 무엇이 있나요라고 묻는 곳도 있었다.
- 자바크스크립트 가비지 컬렉션 알고리즘에 대해서 묻는 곳도 있었다.

### 웹브라우저 관련
- 웹 브라우저에 www.google.com을 치고 엔터를 누르면 일어나는 일에 대해 묻는다. [what happens when type google](https://www.google.com/search?q=what+happens+when+type+google&sxsrf=ALeKk00AIzB-CC-Xn_LS77NhQ_IYVLu6UA%3A1617619883416&ei=q-tqYPP7GMnFmAXNiYL4Aw&oq=what+happens+when+type&gs_lcp=Cgdnd3Mtd2l6EAMYADICCAAyBQgAEMsBMgUIABDLATIFCAAQywEyBQgAEMsBMgUIABDLATIFCAAQywEyBQgAEMsBMgUIABDLATIFCAAQywE6BwgjELADECc6BAgjECc6CAgAELEDEIMBOgUIABCxAzoHCCMQ6gIQJzoECAAQAzoGCCMQJxATOgQIABBDOgcIABCxAxBDOgQIABAKOgoIABCxAxCDARAKUIi4FViy3BVgmeIVaAJwAHgAgAF_iAGFFJIBBDEuMjOYAQCgAQGqAQdnd3Mtd2l6sAEKyAEBwAEB&sclient=gws-wiz)
- html css js가 브라우저에서 어떻게 렌더링되는지 거의 물어본다. 깊게 들어가면 repainting이나 reflow에 대한 것도 물어본다.
- display:none에서 어느정도까지 새로그리는지 묻는다.
- 네이버나 카카오는 CS면접을 많이 묻기로 유명한데, 인턴연계형 채용면접에서는 거의 묻지 않았다.

### 프로젝트 관련
- 프로젝트 질문은 대기업은 반드시 했고 스타트업은 안 하는 곳도 많았다.
- 기술 사용한 이유에 대해 반드시 물어본다, 특히 상태관리 라이브러리 사용한 것 중 왜 그걸 택했는지, 차이는 뭔지 물어본다.
- 팀프로젝트에서 힘들었던 것, 마찰이 있었을 때 극복한 방법, 동료가 어땠으면 좋겠는지 반드시 물어본다.
- date객체는 현실 시간과 차이가 있는데, 이때 moment 객체를 쓰면 이것을 보상할 수 있는데 이유가 무엇인가. --></div><div class="contents"><ul>
<li>
<p><a href="#1-%EC%A0%84%EC%82%B0-%EA%B8%B0%EC%B4%88">1. 전산 기초</a></p>
<ul>
<li>
<p><a href="#1-1-%EA%B0%9C%EB%B0%9C%EC%83%81%EC%8B%9D">1-1. 개발상식</a></p>
<ul>
<li>
<p><a href="#%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">좋은 코드란 무엇인가</a></p>
</li>
<li>
<p><a href="#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8Doop%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">객체 지향 프로그래밍(OOP)이란 무엇인가</a></p>
</li>
<li>
<p><a href="#%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">함수형 프로그래밍이란 무엇인가</a></p>
</li>
<li>
<p><a href="#api%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">API란 무엇인가</a></p>
<ul>
<li><a href="#restful-api%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">RESTful API란 무엇인가</a></li>
</ul>
</li>
<li>
<p><a href="#tdd%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%9E%A5%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80">TDD란 무엇이며 어떠한 장점이 있는가</a></p>
</li>
<li>
<p><a href="#mvc%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">MVC패턴이란 무엇인가</a></p>
<ul>
<li><a href="#model">Model</a></li>
<li><a href="#view">View</a></li>
<li><a href="#controller">Controller</a></li>
</ul>
</li>
<li>
<p><a href="#git%EA%B3%BC-github%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">Git과 Github은 무엇인가</a></p>
<ul>
<li><a href="#gitflow-vs-github-flow-vs-gitlab-flow">Gitflow vs GitHub flow vs GitLab flow</a></li>
<li><a href="#%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8%ED%95%98%EA%B8%B0">오픈 소스 프로젝트에 컨트리뷰트하기</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#1-2-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0">1-2. 자료구조</a></p>
<ul>
<li>
<p><a href="#array-vs-linked-list">Array vs Linked List</a></p>
<ul>
<li><a href="#array">Array</a></li>
<li><a href="#linked-list">Linked List</a></li>
</ul>
</li>
<li>
<p><a href="#stack-and-queue">Stack and Queue</a></p>
<ul>
<li><a href="#stack">Stack</a></li>
<li><a href="#queue">Queue</a></li>
</ul>
</li>
<li>
<p><a href="#tree">Tree</a></p>
<ul>
<li><a href="#binary-tree">Binary Tree</a></li>
<li><a href="#bstbinary-search-tree">BST(Binary Search Tree)</a></li>
</ul>
</li>
<li>
<p><a href="#red-black-tree">Red Black Tree</a></p>
<ul>
<li><a href="#red-black-tree%EC%9D%98-%EC%A0%95%EC%9D%98">Red Black Tree의 정의</a></li>
<li><a href="#red-black-tree%EC%9D%98-%ED%8A%B9%EC%A7%95">Red Black Tree의 특징</a></li>
<li><a href="#%EC%82%BD%EC%9E%85">삽입</a></li>
<li><a href="#%EC%82%AD%EC%A0%9C">삭제</a></li>
</ul>
</li>
<li>
<p><a href="#binary-heap">Binary Heap</a></p>
</li>
<li>
<p><a href="#hash-table">Hash Table</a></p>
<ul>
<li>
<p><a href="#hash-function">Hash Function</a></p>
</li>
<li>
<p><a href="#resolve-collision">Resolve Collision</a></p>
<ul>
<li>
<p><a href="#open-addressing-%EB%B0%A9%EC%8B%9D-%EA%B0%9C%EB%B0%A9-%EC%A3%BC%EC%86%8C%EB%B2%95">Open Addressing 방식 (개방 주소법)</a></p>
</li>
<li>
<p><a href="#separate-chaining-%EB%B0%A9%EC%8B%9D-%EB%B6%84%EB%A6%AC-%EC%97%B0%EA%B2%B0%EB%B2%95">Separate Chaining 방식 (분리 연결법)</a></p>
<ul>
<li><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%EC%A0%81%EB%8B%A4%EB%8A%94-%EA%B2%83%EC%9D%80-%EC%96%BC%EB%A7%88%EB%82%98-%EC%A0%81%EB%8B%A4%EB%8A%94-%EA%B2%83%EC%9D%84-%EC%9D%98%EB%AF%B8%ED%95%98%EB%8A%94%EA%B0%80">데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?</a></li>
<li><a href="#%ED%95%9C-%EA%B0%80%EC%A7%80-%EC%83%81%ED%99%A9%EC%9D%84-%EA%B0%80%EC%A0%95%ED%95%B4%EB%B3%B4%EC%9E%90">한 가지 상황을 가정해보자.</a></li>
</ul>
</li>
<li>
<p><a href="#open-adderessing-vs-separate-chaining">Open Adderessing vs Separate Chaining</a></p>
</li>
<li>
<p><a href="#%EB%B3%B4%EC%A1%B0-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98supplement-hash-function">보조 해시 함수(Supplement Hash Function)</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#%ED%95%B4%EC%8B%9C-%EB%B2%84%ED%82%B7-%EB%8F%99%EC%A0%81-%ED%99%95%EC%9E%A5resize">해시 버킷 동적 확장(Resize)</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#graph">Graph</a></p>
<ul>
<li>
<p><a href="#%EC%A0%95%EC%A0%90%EA%B3%BC-%EA%B0%84%EC%84%A0%EC%9D%98-%EC%A7%91%ED%95%A9-graph">정점과 간선의 집합, Graph</a></p>
</li>
<li>
<p><a href="#graph-%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC">Graph 관련 용어정리</a></p>
<ul>
<li><a href="#undirected-graph%EC%99%80-directed-graphdigraph">Undirected Graph와 Directed Graph(Digraph)</a></li>
<li><a href="#degree">Degree</a></li>
<li><a href="#%EA%B0%80%EC%A4%91%EC%B9%98-%EA%B7%B8%EB%9E%98%ED%94%84weight-graph%EC%99%80-%EB%B6%80%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84sub-graph">가중치 그래프(Weight Graph)와 부분 그래프(Sub Graph)</a></li>
</ul>
</li>
<li>
<p><a href="#graph-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95">Graph 구현 방법</a></p>
<ul>
<li><a href="#%EC%9D%B8%EC%A0%91-%ED%96%89%EB%A0%ACadjacent-matrix--%EC%A0%95%EB%B0%A9-%ED%96%89%EB%A0%AC%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95">인접 행렬(Adjacent matrix) : 정방 행렬을 사용하는 방법</a></li>
<li><a href="#%EC%9D%B8%EC%A0%91-%EB%A6%AC%EC%8A%A4%ED%8A%B8adjacent-list--%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95">인접 리스트(Adjacent list) : 연결 리스트를 사용하는 방법</a></li>
</ul>
</li>
<li>
<p><a href="#graph-%ED%83%90%EC%83%89">Graph 탐색</a></p>
<ul>
<li><a href="#%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89depth-first-searchs--dfs">깊이 우선 탐색(Depth First Searchs : DFS)</a></li>
<li><a href="#%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89breadth-first-searchs--bfs">너비 우선 탐색(Breadth First Searchs : BFS)</a></li>
</ul>
</li>
<li>
<p><a href="#minimum-spanning-tree">Minimum Spanning Tree</a></p>
<ul>
<li><a href="#kruskal-algorithm">Kruskal algorithm</a></li>
<li><a href="#prim-algorithm">Prim algorithm</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#1-3-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC">1-3. 네트워크</a></p>
<ul>
<li>
<p><a href="#http%EC%9D%98-get%EA%B3%BC-post-%EB%B9%84%EA%B5%90">HTTP의 GET과 POST 비교</a></p>
<ul>
<li><a href="#get">GET</a></li>
<li><a href="#post">POST</a></li>
<li><a href="#%EB%B9%84%EA%B5%90">비교</a></li>
</ul>
</li>
<li>
<p><a href="#http%EC%99%80-https">HTTP와 HTTPS</a></p>
<ul>
<li>
<p><a href="#http%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90">HTTP의 문제점</a></p>
<ul>
<li>
<p><a href="#tcpip%EB%8A%94-%EB%8F%84%EC%B2%AD%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%B4%EB%8B%A4">TCP/IP는 도청이 가능한 네트워크이다.</a></p>
<ul>
<li><a href="#%EB%B3%B4%EC%95%88-%EB%B0%A9%EB%B2%95">보안 방법</a></li>
</ul>
</li>
<li>
<p><a href="#%ED%86%B5%EC%8B%A0-%EC%83%81%EB%8C%80%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%9C%84%EC%9E%A5%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4">통신 상대를 확인하지 않기 때문에 위장이 가능하다.</a></p>
<ul>
<li><a href="#%EB%B3%B4%EC%95%88-%EB%B0%A9%EB%B2%95-1">보안 방법</a></li>
</ul>
</li>
<li>
<p><a href="#%EC%99%84%EC%A0%84%EC%84%B1%EC%9D%84-%EC%A6%9D%EB%AA%85%ED%95%A0-%EC%88%98-%EC%97%86%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EB%B3%80%EC%A1%B0%EA%B0%80-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4">완전성을 증명할 수 없기 때문에 변조가 가능하다.</a></p>
<ul>
<li><a href="#%EB%B3%B4%EC%99%84-%EB%B0%A9%EB%B2%95">보완 방법</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#https">HTTPS</a></p>
<ul>
<li><a href="#%EB%AA%A8%EB%93%A0-%EC%9B%B9-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%97%90%EC%84%9C-https%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%8F%84-%EB%90%A0%EA%B9%8C">모든 웹 페이지에서 HTTPS를 사용해도 될까?</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#tcp%EC%99%80-udp">TCP와 UDP</a></p>
<ul>
<li><a href="#udpuser-datagram-protocol-%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C">UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)</a></li>
<li><a href="#tcptransmission-control-protocol-%EC%A0%84%EC%86%A1-%EC%A0%9C%EC%96%B4-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C">TCP(Transmission Control Protocol, 전송 제어 프로토콜)</a></li>
</ul>
</li>
<li>
<p><a href="#3-way-handshake">3-way-handshake</a></p>
<ul>
<li><a href="#%EC%99%9C-3-way%EC%9D%B8%EA%B0%80-2-way%EB%A1%9C%EB%8A%94-%EC%B6%A9%EB%B6%84%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80%EA%B0%80">왜 3-way인가? 2-way로는 충분하지 않은가?</a></li>
</ul>
</li>
<li>
<p><a href="#dns-round-robin-%EB%B0%A9%EC%8B%9D">DNS Round Robin 방식</a></p>
<ul>
<li>
<p><a href="#dns-round-robin-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90">DNS Round Robin 방식의 문제점</a></p>
</li>
<li>
<p><a href="#%EB%AC%B8%EC%A0%9C%EC%A0%90-%ED%95%B4%EC%86%8C-%EA%B8%B0%EB%B2%95">문제점 해소 기법</a></p>
<ul>
<li><a href="#weighted-round-robinwrr">Weighted Round Robin(WRR)</a></li>
<li><a href="#least-connection">Least Connection</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EC%9B%B9-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%81%B0-%ED%9D%90%EB%A6%84---%EC%9A%B0%EB%A6%AC%EA%B0%80-chrome%EC%9D%84-%EC%8B%A4%ED%96%89%EC%8B%9C%EC%BC%9C-%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-%ED%8A%B9%EC%A0%95-url%EA%B0%92%EC%9D%84-%EC%9E%85%EB%A0%A5%EC%8B%9C%ED%82%A4%EB%A9%B4-%EC%96%B4%EB%96%A4-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C">웹 통신의 큰 흐름 - 우리가 chrome을 실행시켜 주소창에 특정 URL값을 입력시키면 어떤 일이 일어날까?</a></p>
<ul>
<li><a href="#in-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80">in 브라우저</a></li>
<li><a href="#in-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D-lan-%EC%96%B4%EB%8C%91%ED%84%B0">in 프로토콜 스택, LAN 어댑터</a></li>
<li><a href="#in-%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0">in 허브, 스위치, 라우터</a></li>
<li><a href="#in-%EC%95%A1%EC%84%B8%EC%8A%A4-%ED%9A%8C%EC%84%A0-%ED%94%84%EB%A1%9C%EB%B0%94%EC%9D%B4%EB%8D%94">in 액세스 회선, 프로바이더</a></li>
<li><a href="#in-%EB%B0%A9%ED%99%94%EB%B2%BD-%EC%BA%90%EC%8B%9C%EC%84%9C%EB%B2%84">in 방화벽, 캐시서버</a></li>
<li><a href="#in-%EC%9B%B9%EC%84%9C%EB%B2%84">in 웹서버</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#1-4-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C">1-4. 운영체제</a></p>
<ul>
<li>
<p><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4">프로세스와 스레드의 차이</a></p>
<ul>
<li>
<p><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4process">프로세스(Process)</a></p>
<ul>
<li>
<p><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9Dprocess-control-block-pcb">프로세스 제어 블록(Process Control Block, PCB)</a></p>
<ul>
<li><a href="#pcb%EC%97%90-%EC%A0%80%EC%9E%A5%EB%90%98%EB%8A%94-%EC%A0%95%EB%B3%B4">PCB에 저장되는 정보</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EC%8A%A4%EB%A0%88%EB%93%9Cthread">스레드(Thread)</a></p>
<ul>
<li><a href="#%EC%8A%A4%ED%83%9D%EC%9D%84-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A7%88%EB%8B%A4-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%A0%EB%8B%B9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0">스택을 스레드마다 독립적으로 할당하는 이유</a></li>
<li><a href="#pc-register%EB%A5%BC-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A7%88%EB%8B%A4-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%A0%EB%8B%B9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0">PC Register를 스레드마다 독립적으로 할당하는 이유</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C">멀티 스레드</a></p>
<ul>
<li><a href="#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%94%A9%EC%9D%98-%EC%9E%A5%EC%A0%90">멀티 스레딩의 장점</a></li>
<li><a href="#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%94%A9%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90">멀티 스레딩의 문제점</a></li>
<li><a href="#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C-vs-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4">멀티 스레드 vs 멀티 프로세스</a></li>
</ul>
</li>
<li>
<p><a href="#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC">스케줄러</a></p>
<ul>
<li><a href="#%EC%9E%A5%EA%B8%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AClong-term-scheduler-or-job-scheduler">장기 스케줄러(Long-term scheduler or job scheduler)</a></li>
<li><a href="#%EB%8B%A8%EA%B8%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%ACshort-term-scheduler-or-cpu-scheduler">단기 스케줄러(Short-term scheduler or CPU scheduler)</a></li>
<li><a href="#%EC%A4%91%EA%B8%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%ACmedium-term-scheduler-or-swapper">중기 스케줄러(Medium-term scheduler or Swapper)</a></li>
</ul>
</li>
<li>
<p><a href="#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC">CPU 스케줄러</a></p>
<ul>
<li>
<p><a href="#fcfsfirst-come-first-saved">FCFS(First Come First Saved)</a></p>
<ul>
<li><a href="#%ED%8A%B9%EC%A7%95">특징</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C%EC%A0%90">문제점</a></li>
</ul>
</li>
<li>
<p><a href="#sjfshortest-job-first">SJF(Shortest Job First)</a></p>
<ul>
<li><a href="#%ED%8A%B9%EC%A7%95-1">특징</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C%EC%A0%90-1">문제점</a></li>
</ul>
</li>
<li>
<p><a href="#srtfshortest-remaining-time-first">SRTF(Shortest Remaining Time First)</a></p>
<ul>
<li><a href="#%ED%8A%B9%EC%A7%95-2">특징</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C%EC%A0%90-2">문제점</a></li>
</ul>
</li>
<li>
<p><a href="#priority-scheduling">Priority Scheduling</a></p>
<ul>
<li><a href="#%ED%8A%B9%EC%A7%95-3">특징</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C%EC%A0%90-3">문제점</a></li>
<li><a href="#%ED%95%B4%EA%B2%B0%EC%B1%85">해결책</a></li>
</ul>
</li>
<li>
<p><a href="#rrround-robin">RR(Round Robin)</a></p>
<ul>
<li><a href="#%ED%8A%B9%EC%A7%95-4">특징</a></li>
<li><a href="#%EC%9E%A5%EC%A0%90">장점</a></li>
<li><a href="#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90">주의할 점</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%9D%98-%EC%B0%A8%EC%9D%B4">동기와 비동기의 차이</a></p>
<ul>
<li><a href="#%EB%B9%84%EC%9C%A0%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%89%AC%EC%9A%B4-%EC%84%A4%EB%AA%85">비유를 통한 쉬운 설명</a></li>
<li><a href="#sync-vs-async">Sync vs Async</a></li>
</ul>
</li>
<li>
<p><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94">프로세스 동기화</a></p>
<ul>
<li>
<p><a href="#critical-section%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD">Critical Section(임계영역)</a></p>
</li>
<li>
<p><a href="#critical-section-problem%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD-%EB%AC%B8%EC%A0%9C">Critical Section Problem(임계영역 문제)</a></p>
</li>
<li>
<p><a href="#requirements%ED%95%B4%EA%B2%B0%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B8%B0%EB%B3%B8%EC%A1%B0%EA%B1%B4">Requirements(해결을 위한 기본조건)</a></p>
</li>
<li>
<p><a href="#%ED%95%B4%EA%B2%B0%EC%B1%85-1">해결책</a></p>
<ul>
<li>
<p><a href="#lock">Lock</a></p>
<ul>
<li><a href="#%ED%95%9C%EA%B3%84">한계</a></li>
</ul>
</li>
<li>
<p><a href="#semaphores%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4">Semaphores(세마포어)</a></p>
<ul>
<li><a href="#%EC%A2%85%EB%A5%98">종류</a></li>
<li><a href="#%EB%8B%A8%EC%A0%90">단점</a></li>
</ul>
</li>
<li>
<p><a href="#%EB%AA%A8%EB%8B%88%ED%84%B0">모니터</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5">메모리 관리 전략</a></p>
<ul>
<li><a href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%B0%B0%EA%B2%BD">메모리 관리 배경</a></li>
<li><a href="#paging%ED%8E%98%EC%9D%B4%EC%A7%95">Paging(페이징)</a></li>
<li><a href="#segmentation%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98">Segmentation(세그멘테이션)</a></li>
</ul>
</li>
<li>
<p><a href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC">가상 메모리</a></p>
<ul>
<li>
<p><a href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%9C%EB%B0%9C-%EB%B0%B0%EA%B2%BD">가상 메모리 개발 배경</a></p>
</li>
<li>
<p><a href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%ED%95%98%EB%8A%94-%EC%9D%BC">가상 메모리가 하는 일</a></p>
<ul>
<li><a href="#%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84">가상 주소 공간</a></li>
<li><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84%EC%9D%98-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B3%B5%EC%9C%A0">프로세스 간의 페이지 공유</a></li>
</ul>
</li>
<li>
<p><a href="#demand-paging%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95">Demand Paging(요구 페이징)</a></p>
</li>
<li>
<p><a href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC">페이지 부재</a></p>
<ul>
<li><a href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC-%EC%8B%9C-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95">페이지 부재 시 동작 과정</a></li>
</ul>
</li>
<li>
<p><a href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4">페이지 교체</a></p>
<ul>
<li>
<p><a href="#%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EB%B0%A9%EB%B2%95">기본적인 방법</a></p>
</li>
<li>
<p><a href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">페이지 교체 알고리즘</a></p>
<ul>
<li><a href="#fifo-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4">FIFO 페이지 교체</a></li>
<li><a href="#%EC%B5%9C%EC%A0%81-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4opt--optimal-page-replacement">최적 페이지 교체(OPT : OPTimal page replacement)</a></li>
<li><a href="#lru-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4lru-page-replacement">LRU 페이지 교체(LRU Page Replacement)</a></li>
<li><a href="#lfu-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4lfu-page-replacement">LFU 페이지 교체(LFU Page Replacement)</a></li>
<li><a href="#mfu-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4mfu-page-replacement">MFU 페이지 교체(MFU Page Replacement)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%A7%80%EC%97%AD%EC%84%B1">캐시의 지역성</a></p>
<ul>
<li><a href="#%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%A7%80%EC%97%AD%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC">캐시의 지역성의 원리</a></li>
<li><a href="#caching-line">Caching Line</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">데이터베이스</a></p>
<ul>
<li>
<p><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9C%EC%9A%94">데이터베이스 개요</a></p>
<ul>
<li><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0">데이터베이스를 사용하는 이유</a></li>
<li><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%ED%8A%B9%EC%A7%95">데이터베이스의 특징</a></li>
<li><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%84%B1%EB%8A%A5">데이터베이스의 성능</a></li>
</ul>
</li>
<li>
<p><a href="#index">Index</a></p>
<ul>
<li>
<p><a href="#%EC%9D%B8%EB%8D%B1%EC%8A%A4index%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">인덱스(Index)란 무엇인가?</a></p>
</li>
<li>
<p><a href="#index-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0">Index 자료구조</a></p>
<ul>
<li><a href="#b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">B+-Tree 인덱스 알고리즘</a></li>
<li><a href="#hash-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">Hash 인덱스 알고리즘</a></li>
<li><a href="#%EC%99%9C-index%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%8D%B0%EC%97%90-b-tree%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80">왜 Index를 생성하는 데에 B-tree를 사용하는가?</a></li>
</ul>
</li>
<li>
<p><a href="#clustered-index">Clustered Index</a></p>
</li>
<li>
<p><a href="#primary-index-vs-secondary-index">Primary Index vs Secondary Index</a></p>
</li>
<li>
<p><a href="#composite-index">Composite Index</a></p>
</li>
<li>
<p><a href="#index%EC%9D%98-%EC%84%B1%EB%8A%A5%EA%B3%BC-%EA%B3%A0%EB%A0%A4%ED%95%B4%EC%95%BC%ED%95%A0-%EC%82%AC%ED%95%AD">Index의 성능과 고려해야할 사항</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#%EC%A0%95%EA%B7%9C%ED%99%94">정규화</a></p>
<ul>
<li>
<p><a href="#%EC%A0%95%EA%B7%9C%ED%99%94%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%B0%B0%EA%B2%BD%EC%97%90%EC%84%9C-%EC%83%9D%EA%B2%A8%EB%82%AC%EB%8A%94%EA%B0%80">정규화는 어떤 배경에서 생겨났는가?</a></p>
<ul>
<li><a href="#%EA%B0%B1%EC%8B%A0-%EC%9D%B4%EC%83%81%EC%97%90%EB%8A%94-%EC%96%B4%EB%96%A0%ED%95%9C-%EA%B2%83%EB%93%A4%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80">갱신 이상에는 어떠한 것들이 있는가?</a></li>
</ul>
</li>
<li>
<p><a href="#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%A0%95%EA%B7%9C%ED%99%94%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">그래서 정규화란 무엇인가?</a></p>
<ul>
<li><a href="#%EB%82%98%EC%81%9C-%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%8C%8C%EC%95%85%ED%95%98%EB%8A%94%EA%B0%80">'나쁜' 릴레이션은 어떻게 파악하는가?</a></li>
<li><a href="#%ED%95%A8%EC%88%98%EC%A0%81-%EC%A2%85%EC%86%8D%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">함수적 종속성이란 무엇인가?</a></li>
<li><a href="#%EA%B0%81%EA%B0%81%EC%9D%98-%EC%A0%95%EA%B7%9C%ED%98%95%EC%9D%80-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EB%A7%8C%EC%A1%B1%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80">각각의 정규형은 어떠한 조건을 만족해야 하는가?</a></li>
</ul>
</li>
<li>
<p><a href="#%EC%A0%9C1-%EC%A0%95%EA%B7%9C%ED%98%95">제1 정규형</a></p>
</li>
<li>
<p><a href="#%EC%A0%9C2-%EC%A0%95%EA%B7%9C%ED%98%95">제2 정규형</a></p>
</li>
<li>
<p><a href="#%EC%A0%9C3-%EC%A0%95%EA%B7%9C%ED%98%95">제3 정규형</a></p>
</li>
<li>
<p><a href="#bcnfboyce-codd%EC%A0%95%EA%B7%9C%ED%98%95">BCNF(Boyce-codd)정규형</a></p>
</li>
<li>
<p><a href="#%EC%A0%95%EA%B7%9C%ED%99%94%EC%97%90%EB%8A%94-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%9E%A5%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80">정규화에는 어떠한 장점이 있는가?</a></p>
</li>
<li>
<p><a href="#%EB%8B%A8%EC%A0%90%EC%9D%80-%EC%97%86%EB%8A%94%EA%B0%80">단점은 없는가?</a></p>
</li>
<li>
<p><a href="#%EB%8B%A8%EC%A0%90%EC%97%90%EC%84%9C-%EB%AF%B8%EB%A3%A8%EC%96%B4-%EB%B3%B4%EC%95%98%EC%9D%84-%EB%95%8C-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%83%81%ED%99%A9%EC%97%90%EC%84%9C-%EC%A0%95%EA%B7%9C%ED%99%94%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80-%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8C%80%EC%9D%91%EC%B1%85%EC%9D%80">단점에서 미루어 보았을 때 어떠한 상황에서 정규화를 진행해야 하는가? 단점에 대한 대응책은?</a></p>
<ul>
<li><a href="#%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94de-normalzation-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94">반정규화(De-normalzation, 비정규화)</a></li>
<li><a href="#%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94%EC%9D%98-%EB%8C%80%EC%83%81%EC%9D%B4-%EB%90%98%EB%8A%94%EA%B0%80">무엇이 반정규화의 대상이 되는가?</a></li>
<li><a href="#%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90%EC%9D%80">반정규화 과정에서 주의할 점은?</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#transaction">Transaction</a></p>
<ul>
<li>
<p><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">트랜잭션이란 무엇인가?</a></p>
</li>
<li>
<p><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-lock">트랜잭션과 Lock</a></p>
</li>
<li>
<p><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%ED%8A%B9%EC%84%B1">트랜잭션의 특성</a></p>
<ul>
<li><a href="#%EC%9B%90%EC%9E%90%EC%84%B1atomicity">원자성(Atomicity)</a></li>
<li><a href="#%EC%9D%BC%EA%B4%80%EC%84%B1consistency">일관성(Consistency)</a></li>
<li><a href="#%EA%B3%A0%EB%A6%BD%EC%84%B1isolation">고립성(Isolation)</a></li>
<li><a href="#%EC%A7%80%EC%86%8D%EC%84%B1durability">지속성(Durability)</a></li>
</ul>
</li>
<li>
<p><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EC%83%81%ED%83%9C">트랜잭션의 상태</a></p>
<ul>
<li><a href="#active">Active</a></li>
<li><a href="#partially-committed">Partially Committed</a></li>
<li><a href="#failed">Failed</a></li>
<li><a href="#committed">Committed</a></li>
<li><a href="#aborted">Aborted</a></li>
<li><a href="#partially-committed%EC%99%80-committed%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90">Partially Committed와 Committed의 차이점</a></li>
</ul>
</li>
<li>
<p><a href="#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90">트랜잭션을 사용할 때 주의할 점</a></p>
</li>
<li>
<p><a href="#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9Cdeadlock">교착상태(DeadLock)</a></p>
<ul>
<li><a href="#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">교착상태란 무엇인가</a></li>
<li><a href="#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%EC%9D%98-%EC%98%88mysql">교착상태의 예(MySQL)</a></li>
<li><a href="#%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C%EC%9D%98-%EB%B9%88%EB%8F%84%EB%A5%BC-%EB%82%AE%EC%B6%94%EB%8A%94-%EB%B0%A9%EB%B2%95">교착 상태의 빈도를 낮추는 방법</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#statement-vs-preparedstatement">Statement vs PreparedStatement</a></p>
</li>
<li>
<p><a href="#nosql">NoSQL</a></p>
<ul>
<li>
<p><a href="#%EC%A0%95%EC%9D%98">정의</a></p>
</li>
<li>
<p><a href="#cap%EC%9D%B4%EB%A1%A0">CAP이론</a></p>
<ul>
<li><a href="#%EC%9D%BC%EA%B4%80%EC%84%B1consistency-1">일관성(Consistency)</a></li>
<li><a href="#%EA%B0%80%EC%9A%A9%EC%84%B1availability">가용성(Availability)</a></li>
<li><a href="#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B6%84%ED%95%A0-%ED%97%88%EC%9A%A9%EC%84%B1partition-tolerance">네트워크 분할 허용성(Partition tolerance)</a></li>
</ul>
</li>
<li>
<p><a href="#%EC%A0%80%EC%9E%A5-%EB%B0%A9%EC%8B%9D%EC%97%90-%EB%94%B0%EB%A5%B8-nosql%EB%B6%84%EB%A5%98">저장 방식에 따른 NoSQL분류</a></p>
<ul>
<li><a href="#key-value-model">Key-Value Model</a></li>
<li><a href="#document-model">Document Model</a></li>
<li><a href="#column-model">Column Model</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#2-javascript">2. JavaScript</a></p>
<ul>
<li>
<p><a href="#js-event-loop">JS Event Loop</a></p>
</li>
<li>
<p><a href="#hoisting">Hoisting</a></p>
<ul>
<li><a href="#%EC%A0%95%EC%9D%98-1">정의</a></li>
</ul>
</li>
<li>
<p><a href="#closure">Closure</a></p>
<ul>
<li><a href="#%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0">클로저 생성하기</a></li>
</ul>
</li>
<li>
<p><a href="#what-is-this">what is 'this'</a></p>
<ul>
<li>
<p><a href="#%EC%83%81%ED%99%A9-1-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%A0-%EB%95%8C">상황 1. 객체의 메소드를 호출할 때</a></p>
</li>
<li>
<p><a href="#%EC%83%81%ED%99%A9-2-%ED%95%A8%EC%88%98%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%A0-%EB%95%8C">상황 2. 함수를 호출할 때</a></p>
</li>
<li>
<p><a href="#%EC%83%81%ED%99%A9-3-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%B4-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%A0-%EB%95%8C">상황 3. 생성자 함수를 통해 객체를 생성할 때</a></p>
</li>
<li>
<p><a href="#%EC%83%81%ED%99%A9-4-apply-call-bind%EB%A5%BC-%ED%86%B5%ED%95%9C-%ED%98%B8%EC%B6%9C">상황 4. apply, call, bind를 통한 호출</a></p>
<ul>
<li><a href="#code-classlanguage-textbindcode-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%82%AC%EC%9A%A9"><code class="language-text">bind</code> 메소드 사용</a></li>
<li><a href="#code-classlanguage-textcallcode-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%82%AC%EC%9A%A9"><code class="language-text">call</code> 메소드 사용</a></li>
<li><a href="#code-classlanguage-textapplycode-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%82%AC%EC%9A%A9"><code class="language-text">apply</code> 메소드 사용</a></li>
<li><a href="#code-classlanguage-textbindcode-vs-code-classlanguage-textapplycode-code-classlanguage-textcallcode"><code class="language-text">bind</code> vs <code class="language-text">apply</code>, <code class="language-text">call</code></a></li>
<li><a href="#code-classlanguage-textapplycode-vs-bind-code-classlanguage-textcallcode"><code class="language-text">apply</code> vs bind, <code class="language-text">call</code></a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#promise">Promise</a></p>
<ul>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
<li>
<p><a href="#asyncawait">Async/Await</a></p>
<ul>
<li><a href="#reference-1">Reference</a></li>
</ul>
</li>
<li>
<p><a href="#arrow-function">Arrow Function</a></p>
<ul>
<li><a href="#%EC%A7%A7%EC%9D%80-%ED%95%A8%EC%88%98">짧은 함수</a></li>
<li><a href="#%EC%83%81%EC%9C%84-%EC%8A%A4%EC%BD%94%ED%94%84-this">상위 스코프 this</a></li>
<li><a href="#reference-2">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#3-frontend">3. FrontEnd</a></p>
<ul>
<li>
<p><a href="#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC">브라우저의 작동 원리</a></p>
</li>
<li>
<p><a href="#document-object-model">Document Object Model</a></p>
<ul>
<li><a href="#event-bubbling-and-capturing">Event Bubbling and Capturing</a></li>
<li><a href="#event-delegation">Event Delegation</a></li>
</ul>
</li>
<li>
<p><a href="#cors">CORS</a></p>
</li>
<li>
<p><a href="#ajax">AJAX</a></p>
</li>
<li>
<p><a href="#%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EA%B4%80%EB%A0%A8%EB%90%9C-issues">웹 성능 관련된 Issues</a></p>
</li>
<li>
<p><a href="#%EC%84%9C%EB%B2%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81-vs-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81">서버 사이드 렌더링 vs 클라이언트 사이드 렌더링</a></p>
</li>
<li>
<p><a href="#css-methodology">CSS Methodology</a></p>
</li>
<li>
<p><a href="#normalizecss-vs-reactcss">Normalize.css vs React.css</a></p>
</li>
<li>
<p><a href="#%EA%B7%B8-%EC%99%B8-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B4%80%EB%A0%A8">그 외 프론트엔드 개발 환경 관련</a></p>
</li>
<li>
<p><a href="#%EC%B6%94%EA%B0%80%EC%9E%90%EB%A3%8C%EB%93%A4">추가자료들</a></p>
</li>
</ul>
</li>
</ul></div></div></main></div><button class="toTheTop" style="bottom:-40px;border:none;z-index:3;background-image:url(https://user-images.githubusercontent.com/71132893/104469041-7ef3ef00-55fb-11eb-873f-3d13378914e9.png);background-position:center;background-repeat:no-repeat;background-size:20px;cursor:pointer;text-align:center;position:fixed;transition:all linear .2s;right:30px;width:38px;height:38px;background-color:#e9e9e9;border-radius:38px;font-size:0;outline:none">-</button><footer style="font-size:12px;position:absolute;bottom:0;background-color:#e9e9e9;height:50px"><div style="font-weight:600;float:left">Follow me in </div><ul style="float:left;margin:0;padding:0;display:flex;flex-flow:row wrap"><li style="list-style:none"><a href="https://github.com/Ho-s"><div style="margin:0 2px 0px 20px;float:left;width:15px;height:15px;background-image:url(https://user-images.githubusercontent.com/71132893/103414512-a1304a80-4bc1-11eb-93ee-b4bd31af9e57.png);background-repeat:no-repeat;background-size:contain"></div><div style="font-weight:600;color:black;float:left">Github</div></a></li><li style="list-style:none"><a href="mailto:kjcoco13@gmail.com"><div style="margin:0 2px 0px 20px;float:left;width:15px;height:15px;background-image:url(https://user-images.githubusercontent.com/71132893/103415271-bd81b680-4bc4-11eb-8ddc-08f84d52f406.png);background-repeat:no-repeat;background-size:contain"></div><div style="font-weight:600;color:black;float:left">Gmail</div></a></li><li style="list-style:none"><a href="https://www.facebook.com/byungho.joo.5/"><div style="margin:0 2px 0px 20px;float:left;width:15px;height:15px;background-image:url(https://user-images.githubusercontent.com/71132893/104439445-76d48900-55d4-11eb-823e-5d1d60b92497.png);background-repeat:no-repeat;background-size:contain"></div><div style="font-weight:600;color:black;float:left">Facebook</div></a></li><li style="list-style:none"><a href="http://qr.kakao.com/talk/Qs4iWKmmtszYlS_qLsk9msnspqs-"><div style="margin:0 2px 0px 20px;float:left;width:15px;height:15px;background-image:url(https://user-images.githubusercontent.com/71132893/112701624-7e69b580-8ed4-11eb-8512-eef46767ed98.png);background-repeat:no-repeat;background-size:contain"></div><div style="font-weight:600;color:black;float:left">Kakao</div></a></li></ul><div style="margin-top:30px">© 2021 Ho&#x27; Space. Powered by graphql &amp; Gatsby.</div></footer></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/technicalNote/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-72b219bae196683411be.js"],"app":["/app-595cc7b5ec9c7c78be0e.js"],"component---markdown-template-js":["/component---markdown-template-js-20dc476c4a1ff5faaff2.js"],"component---src-pages-404-js":["/component---src-pages-404-js-eb46f0486b87e1fb75b7.js"],"component---src-pages-about-jsx":["/component---src-pages-about-jsx-030c1b8ceb24754c1d90.js"],"component---src-pages-blog-jsx":["/component---src-pages-blog-jsx-6aba48eb36904f289429.js"],"component---src-pages-contact-jsx":["/component---src-pages-contact-jsx-4581b3082f03ec0a7e3f.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-2b1f96952e230c6cec3e.js"],"component---src-pages-projects-jsx":["/component---src-pages-projects-jsx-02a53d1d00a5d5e46e3b.js"]};/*]]>*/</script><script src="/polyfill-72b219bae196683411be.js" nomodule=""></script><script src="/component---markdown-template-js-20dc476c4a1ff5faaff2.js" async=""></script><script src="/app-595cc7b5ec9c7c78be0e.js" async=""></script><script src="/framework-75034fa8e3a9e81ff051.js" async=""></script><script src="/webpack-runtime-e851f4dc4f972090e163.js" async=""></script></body></html>