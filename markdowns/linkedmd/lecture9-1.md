---
date: "2021-01-09"
title: "알고리즘 공부 기록/강의9-1"
path: "/lecture/9-1"
---

## 소수 판별 알고리즘
- 소수(Prime Number)
    - **소수**란 <u>**1**보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어떨어지지 않는 자연수</u>이다.
        -**6**은 1,2,3,6으로 나누어 떨어지므로 소수가 아니다.
        -**7**은 1과 7을 제외하고는 나누어 떨이지지 않으므로 소수이다.
    - 코딩테스트에서는 어떠한 자연수가 소수인지 아닌지 판별해야 하는 문제가 자주 출제된다.

- 소수의 판별: 기본적인 알고리즘 (Python)
```python
#소수 판별(2 이상의 자연수에 대하여)
def is_prime_number(x):
    #2부터 (x-1)까지의 모든 수를 확인하며
    for i in range(2,x):
        #x가 해당 수로 나누어 떨어진다면
        if x % i ==0:
            return False #소수가 아님
    return  True #소수임

print(is_prime_number(4)) # False
print(is_prime_number(7)) # True
```

- 소수의 판별: 기본적인 알고리즘 성능 분석
    - 2부터 x-1까지의 모든 자연수에 대하여 연산을 수행해야 한다.
        - 모든 수를 하나씩 확인한다는 점에서 시간 복잡도는 **_O_(_X_)**이다.

- 약수의 성질
    - **모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭**을 이루는 것을 알 수 있다.
        - 예를 들어 16의 약수는 1, 2, 4, 8, 16이다.
        - 이때 2 X 8 = 16은 8 X 2 = 16과 대칭이다.
    - 따라서 우리는 특정한 자연수의 모든 약수를 찾을 때 <u>가운데 약수(제곱근)까지만 확인</u>하면 된다.
        - 예를 들어 16이 2로 나누어 떨어진다는 것은 8로도 나누어떨어진다는 것을 의미한다.
        ![image](https://user-images.githubusercontent.com/71132893/104083480-41513800-5282-11eb-94fc-c0a96459c946.png)

- 소수의 판별: 개선된 알고리즘(python)
```python
import math

#소수 판별(2 이상의 자연수에 대하여)
def is_prime_number(x):
    #2부터 x의 제곱근까지의 모든 수를 확인하며
    for i in range(2,int(math.sqrt(x) + 1)):
        #x가 해당 수로 나누어 떨어진다면
        if x % i ==0:
            return False #소수가 아님
    return  True #소수임

print(is_prime_number(4)) # False
print(is_prime_number(7)) # True
```

- 소수의 판별: 개선된 알고리즘 성능 분석
    - 2부터 X의 제곱근(소수점 이하 무시)까지의 모든 자연수에 대하여 연산을 수행해야 한다.
    - 시간복잡도는 **_O_(_N<sup>1/2</sup>_)**이다.

- 다수의 소수 판별
    - 하나의 수에 대해서 소수인지 아닌지 판별하는 방법을 알아보았다.
    - 하지만 <u>특정한 수의 범위 안에 존재하는 모든 소수</u>를 찾아야 할 때 어떻게 할까?
        - **에라토스테네스의 체 알고리즘**을 사용할 수 있다.

### 에라토스테네스의 체
- 에라토테네스의 체 개요
    - <u>다수의 자연수에 대하여 소수 여부를 판별</u>할 때 사용하는 대표적인 알고리즘이다.
    - 에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있다.
    - 에라토스테네스의 체 알고리즘의 **구체적인 동작 과정**은 다음과 같다.
        1. 2부터 N까지의 모든 자연수를 나열한다.
        1. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 *i*를 찾는다.
        1. 남은 수 중에서 *i*의 배수를 모두 제거한다.(*i*는 제거하지 않는다.)
        1. 더 이상 반복할 수 없을 때까지 2번과 3번 과정을 반복한다.
- 동작 예시
![image](https://user-images.githubusercontent.com/71132893/104083685-05b76d80-5284-11eb-99e2-358b5623766c.png)
![image](https://user-images.githubusercontent.com/71132893/104083693-0bad4e80-5284-11eb-8fde-f9a484ec9888.png)
![image](https://user-images.githubusercontent.com/71132893/104083699-1536b680-5284-11eb-871e-0ffb9b9dcd06.png)
![image](https://user-images.githubusercontent.com/71132893/104083705-1e278800-5284-11eb-8b27-2fd20e3513aa.png)
![image](https://user-images.githubusercontent.com/71132893/104083708-2384d280-5284-11eb-9172-1f1aba9801cb.png)

-에라토스테네스의 체 알고리즘 구현 예시(Python)

```python
import math
n = 1000 #2부터 1,000까지의 모든 수에 대하여 소수 판별
# 처음엔 모든 수가 소수(True)인 것으로 초기화(0과 1은 제외)
array = [True for i in range(n + 1)]

#에라토스테네스의 체 알고리즘 수행
#2부터 n의 제곱근까지의 모든 수를 확인하며
for i in range(2, int(math.sqrt(n))+1):
    if array[i] == True: #i가 소수인 경우(남은 수인 경우)
    # i를 제외한 i의 모든 배수를 지우기
    j = 2
    while i * j <= n:
        array[i*j]=False
        j+=1

#모든 소수 출력
for i in range(2, n+1)
    if array[i]:
        print(i, end=' ')
```

- 에라토스테네스의 체 알고리즘 성능 분석
    - 에라토스테네스의 체 알고리즘의 시간 복잡도는 사실상 선형 시간에 가까울 정도로 매우 빠르다.
        - 시간 복잡도는 **_O_(_NloglogN_)**이다.
    - 에라토스테네스의 체 알고리즘은 다수의 소수를 찾아야 하는 문제에서 효과적으로 사용될 수 있다.
        - 하지만 각 자연수에 대한 소수 여부를 저장해야 하므로 **메모리가 많이 필요**하다.
        - **10억**이 소수인지 아닌지 판별해야 할 때 에라토스테네스의 체를 사용할 수 있을까?