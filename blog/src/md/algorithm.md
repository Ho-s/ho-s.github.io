---
date: "2020-12-28"
title: "알고리즘 공부 기록"
path: 'algorithm'
---
# Summary Notes of Algoritm Lecture
출처 : [이코테 2021](https://www.youtube.com/watch?v=m-9pAwq1o3w&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=1&ab_channel=%EB%8F%99%EB%B9%88%EB%82%98)

## 1. 코딩 테스트 출제 경향 분석 및 파이썬 문법 부수기

* 온라인 저지 사이트
    * [코드포스(Codeforces)](http://www.codeforces.com) >국제대회가 열리며 다수의 기출문제 수록
    * [탑코더(TopCoder)](https://www.topcoder.com)
    * [릿코드(LeetCode)](https://leetcode.com) >기업코딩테스트를 위한 다양한 문제들 수록
    * [코드셰프(CODECHEF)](https://www.codechef.com)
    * [백준온라인저지(BOJ)](https://www.acmicpc.net) >많은 국내 대기업 기출문제
    * [코드업(CodeUp)](https://codeup.kr) >초보자들에게 추천
    * [프로그래머스(Programmers)](https://programmers.co.kr)
    * [SW EXPERT Academy](https://swexpertacademy.com)

* 코딩테스트에는 현재 Python과 C++으로 진행하는 것이 유리하다고 생각되어짐.
* 프로그램 개발 방식의 코딩 테스트에서는 Python이 가장 유리하다고 생각 되어짐.
* 알고리즘 코딩 테스트를 준비하는 과정에서 팀노트 등을 작성하며, 자신만의 소스코드를 관리하는 습관을 들이면 좋음.
* 팀 노트 예시 [Github Link](https://github.com/ndb796/ython-Competitive-Programming-Team-Notes)
* 가장 출제 빈도가 높은 알고리즘 유형
    * 그리디(쉬운 난이도)
    * 구현
    * DFS/BFS를 활용한 탐색

* 복잡도는 알고리즘의 성능을 나타내는 척도로, 동일한 기능의 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 좋은 알고리즘임.
    * 시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 수행시간 분석
    * 공간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석
* 빅오 표기법 (Big-O Notation)
    * 가장 빠르게 증가하는 항만을 고려하는 표기법으로, 함수의 상한만을 나태내게 됨.
    * 가령 3N^3^ + 5N^2^+ 1,000,000인 알고리즘이 있다고 할 때 빅오 표기법에서는 차수가 가장 큰 항만을 남기므로 O(N^3^)으로 표현됨.
    * 순위 (아래로 갈 수록 나쁨.)
        * O(1) / 상수 시간(Constant time)
        * O(logN) / 로그 시간(Log time)
        * O(N) / 선형 시간
        * O(NlogN) / 로그 선형 시간
        * O(N^2^) / 이차 시간
        * O(N^3^) / 삼차 시간
        * O(2^n^) / 지수 시간
* 알고리즘 설계 Tip
    * 일반적으로 CPU기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산횟수가 5억을 넘어가는 경우:
        * C언어를 기준으로 통상 1~3초 가량의 시간이 소요됨.
        * Python을 기준으로 통상 5~15초 가량의 시간이 소요되며, PyPy의 경우 떄때로 C언어보다 빠르게 동작하기도 함.
    * 코딩테스트 문제에서 시간제한은 통상 1~5초가량이라는 점에 유의
        * 혹여 명시되어 있지 않은 경우 대략 5초 정도라고 생각하고 문제를 푸는 것이 합리적임.
* 요구사항에 따라 적절한 알고리즘 설계하기
    * 문제에서 가장 먼저 확인해야 하는 내용은 시간제한(수행시간 요구사항)임.
    * 시간제한이 1초인 문제를 만났을 때, 일반적인 기준은 다음과 같음.
        * N의 범위가 500인 경우: 시간 복잡도가 O(N^3^)인 알고리즘을 설계
        * N의 범위가 2,000인 경우: 시간 복잡도가 O(N^2^)인 알고리즘을 설계
        * N의 범위가 100,000인 경우: 시간 복잡도가 O(NlogN)인 알고리즘을 설계
        * N의 범위가 10,000,000인 경우: 시간 복잡도가 O(N)인 알고리즘을 설계
* 일반적인 알고리즘 문제 해결 과정은 다음과 같음
    * 일반적으로 대부분의 문제 출제자들은 핵심 아이디어를 캐치한다면,간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제함.
    1. 지문 읽기 및 컴퓨터적 사고
    1. 요구사항(복잡도)분석
    1. 문제 해결을 위한 아이디어 찾기
    1. 소스코드 설계 및 코딩
    

## 2. 그리디 & 구현
* 그리디알고리즘
    * 그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법임
    * 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구함.
    * 그리디 해법은 정당선 분석이 중요하며, 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토함.  
    * 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많음.
    * 하지만 코딩 테스트에서의 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제가 됨.  
<img src='https://user-images.githubusercontent.com/71132893/103215106-c587ef00-4955-11eb-8be7-2af3976702b9.png' width='280px' height='280px'>
<img src='https://user-images.githubusercontent.com/71132893/103215110-c6208580-4955-11eb-9efe-750b04bba51e.png' width='280px' height='280px'>  
> 좌측의 사진은 구할 수 있는 최고의 경우이지만, 헤아려야 하는 수가 많기때문에, 우측의 사진처럼 각 상황에서의 최고의 조건을 선택함으로서, 최적의 해의 가깝게 되는 값을 구하는 것이 `그리디 알고리즘`임

* <문제> 거스름돈: 요구
<img src='https://user-images.githubusercontent.com/71132893/103215636-4a273d00-4957-11eb-8e1c-ea4cf6ed216b.png'>  
    * 최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐 단위부터 돈을 거슬러 주면 됨.

* <문제> 거스름돈: 정당성 분석
    * 가장 큰 화폐 단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는 무엇일까?
        * 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문
    * 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야함.

* <문제> 거스름돈: 답안 예시(Python)
```python
n=1260
count=0

#큰 단위의 화폐부터 차례대로 확인하기
array=[500,100,50,10]
for coin in array:
    count+=n //coin
    n%=coin

print(count)
```

* <문제> 거스름돈 : 답안 예시(Javascript) *직접 작성*
```js
let n =1260
let count=0

const array=[500,100,50,10]

for(let i=0; i<4; i++){
    count +=parseInt(n/array[i])
    n-=parseInt(n/array[i])*array[i]
}
console.log(count)
```

## 3. DFS & BFS
## 4. 정렬 알고리즘
## 5. 이진 탐색
## 6. 다이나믹 프로그래밍
## 7. 최단 경로 알고리즘
## 8. 기타 그래프 이론
## 9. 코딩 테스트에서 자주 출제되는 기타 알고리즘
## 10. 개발형 코딩 테스트
## 자료구조: 우선순위 큐(Priority Queue)와 힙(Heap) 10분 핵심 요약
## 코딩 테스트를 위한 트리(Tree) 자료구조 10분 핵심 요약
## 코딩 테스트를 위한 벨만 포드 알고리즘 7분 핵심 요약
## 자료구조: 바이너리 인덱스 트리(Binary Indexed Tree, BIT, 펜윅 트리) 10분 정복
## 최소 공통 조상(Lowest Common Ancestor, LCA) 알고리즘 10분 정복