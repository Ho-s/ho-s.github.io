{"componentChunkName":"component---markdown-template-js","path":"/lecture7-1/","result":{"data":{"markdownRemark":{"html":"<h2>다익스트라 최단경로 알고리즘</h2>\n<ul>\n<li>\n<p>최단 경로 문제</p>\n<ul>\n<li>최단 경로 알고리즘은 <strong>가장 짧은 경로를 찾는 알고리즘</strong>을 의미한다.</li>\n<li><strong>다양한 문제 상황</strong></li>\n<li>한 지점에서 다른 한 지점까지의 최단 경로</li>\n<li>한 지점에서 다른 모든 지점까지의 최단 경로</li>\n<li>모든 지점에서 다른 모든 지점까지의 최단 경로</li>\n<li>각 지점은 그래프에서 <strong><span style='color:red'>노드</strong></span>로 표현</li>\n<li>지점 간 연결된 도로는 그래프에서 <strong><span style='color:red'>간선</strong></span>으로 표현\n<img src=\"https://user-images.githubusercontent.com/71132893/103738495-6d2cad80-5037-11eb-9d1f-ee4b54c8f787.png\" alt=\"image\"></li>\n</ul>\n</li>\n<li>\n<p>다익스트라 최단 경로 알고리즘 개요</p>\n<ul>\n<li><strong>특정한 노드</strong>에서 출발하여 <strong>다른 모든 노드</strong>로 가는 최단 경로를 계산한다.</li>\n<li>다익스트라 최단 경로 알고리즘은 음의 간선이 없을 때 정상적으로 동작한다.</li>\n<li>현실 세계의 도로(간선)은 음의 간선으로 표현되지 않는다.</li>\n<li>다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류 된다.</li>\n<li><strong>매 상황에서 가장 비용이 적은 노드를 선택</strong>하여 임의의 과정을 반복한다.</li>\n</ul>\n</li>\n<li>\n<p>알고리즘의 <strong>동작 과정</strong>은 다음과 같다.</p>\n<ol>\n<li>출발 노드를 설정한다.</li>\n<li>최단 거리 테이블을 초기화한다.</li>\n<li>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.</li>\n<li>해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.</li>\n<li>위 과정에서 3번과 4번을 반복한다.</li>\n</ol>\n</li>\n<li>알고리즘 동작 과정에서 최단 거리 테이블은 각 노드에 대한 현재까지의 최단 거리 정보를 가지고 있다.</li>\n<li>처리 과정에서 더 짧은 경로를 찾으면 '이제부터는 이 경로가 제일 짧은 경로야'라고 갱신한다.\n<img src=\"https://user-images.githubusercontent.com/71132893/103739491-09a37f80-5039-11eb-8e2b-9ef19dfc8eae.png\" alt=\"image\"></li>\n<li>동작 과정 살표보기\n<img src=\"https://user-images.githubusercontent.com/71132893/103740536-bdf1d580-503a-11eb-9154-b14ca9e22a75.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103740565-cd711e80-503a-11eb-9d0f-6b85510e80be.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103740626-f2659180-503a-11eb-9623-e8a3d640453e.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103740722-23de5d00-503b-11eb-8e50-7cafca8598dc.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103740787-42445880-503b-11eb-9cb7-955404500290.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103740819-51c3a180-503b-11eb-93b8-1bf9e7847abc.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103740828-5720ec00-503b-11eb-8c92-c5370c1d782d.png\" alt=\"image\"></li>\n<li>\n<p>다익스트라 알고리즘의 특징</p>\n<ul>\n<li>그리디 알고리즘 : <strong>매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택</strong>해 임의의 과정을 반복한다.</li>\n<li>\n<p>단계를 거치며 <span style='color:red'><strong>한 번 처리된 노드의 최단 거리는 고정</strong></span>되어 더 이상 바뀌지 않는다.</p>\n<ul>\n<li><strong>한 단계 당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해</strong>할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>다익스트라 알고리즘을 수행한 뒤에 <u>테이블에 각 노드까지의 최단 거리 정보가 저장</u>된다.</p>\n<ul>\n<li>완벽한 형태의 최단 경로를 구하려면 소스코드에 추가적인 기능을 더 넣어야 한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>다익스트라 알고리즘 간단한 구현 방법</p>\n<ul>\n<li>단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 <strong>매 단계마다 1차원 테이블의 모든 원소를 확인(순차 탐색)</strong>한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수, 간선의 개수를 입력받기</span>\nn<span class=\"token punctuation\">,</span> m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 시작 노드 번호를 입력받기</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 방문한 적이 있는지 체크하는 목적의 리스트를 만들기</span>\nvisited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndistance <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 간선 정보를 입력받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_smallest_node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    min_value <span class=\"token operator\">=</span> INF\n    index <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token comment\"># 가장 최단 거리가 짧은 노드(인덱스)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> min_value <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            min_value <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            index <span class=\"token operator\">=</span> i\n    <span class=\"token keyword\">return</span> index\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 시작 노드에 대해서 초기화</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    visited<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리</span>\n        now <span class=\"token operator\">=</span> get_smallest_node<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        visited<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token comment\"># 현재 노드와 연결된 다른 노드를 확인</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            cost <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> j<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우</span>\n            <span class=\"token keyword\">if</span> cost <span class=\"token operator\">&lt;</span> distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cost\n\n<span class=\"token comment\"># 다익스트라 알고리즘을 수행</span>\ndijkstra<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 노드로 가기 위한 최단 거리를 출력</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 도달할 수 없는 경우, 무한(INFINITY)이라고 출력</span>\n    <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 도달할 수 있는 경우 거리를 출력</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>다익스트라 알고리즘 간단한 구현 방법 성능 분석</p>\n<ul>\n<li>총 O(V)번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색해야 한다.</li>\n<li>따라서 전체 시간 복잡도는 O(V<sup>2</sup>)이다.</li>\n<li>\n<p>일반적으로 코딩 테스트의 최단 경로 문제에서 전체 노드의 개수가 5,000개 이하라면 이 코드로 문제를 해결할 수 있다.</p>\n<ul>\n<li>하지만 노드의 개수가 10,000개를 넘어가는 문제라면 어떻게 해야할까?</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>우선순위 큐(Priority Queue)</p>\n<ul>\n<li><u>우선순위가 가장 높은 데이터를 가장 먼저 삭제</u>하는 자료구조이다.</li>\n<li>예를 들어 여러 개의 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내서 확인해야 하는 경우에 우선순위 큐를 이용할 수 있다.</li>\n<li>Python, C++, Java를 포함한 대부분의 프로그래밍 언어에서 <strong>표준 라이브러리 형태로 지원</strong>한다.\n<img src=\"https://user-images.githubusercontent.com/71132893/103743572-bb45af00-503f-11eb-9a15-05997a229a42.png\" alt=\"image\"></li>\n</ul>\n</li>\n<li>\n<p>힙(Heap)</p>\n<ul>\n<li><u>우선순위 큐(Priority Queue)를 구현하기 위해 사용하는 자료구조 중 하나</u>이다.</li>\n<li><strong>최소 힙(Min Heap)</strong>과 <strong>최대 힙(Max Heap)</strong>이 있다.</li>\n<li>다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에 사용된다.\n<img src=\"https://user-images.githubusercontent.com/71132893/103743679-eb8d4d80-503f-11eb-9c1c-6f44b803c3e6.png\" alt=\"image\"></li>\n<li>힙 라이브러리 사용 예제 : 최소 힙</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> heapq\n\n<span class=\"token comment\">#오름차순 힙 정렬(Haep Sort)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">heapsort</span><span class=\"token punctuation\">(</span>iterable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    h <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 모든 원소를 차례대로 힙에 삽입</span>\n    <span class=\"token keyword\">for</span> value <span class=\"token keyword\">in</span> iterable<span class=\"token punctuation\">:</span>\n        heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">#힙에 삽입된 모든 원소를 차례대로 꺼내어 담기</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        result<span class=\"token punctuation\">.</span>apeend<span class=\"token punctuation\">(</span>heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> result\n\nresult <span class=\"token operator\">=</span> heapsort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span></code></pre></div>\n<p>-힙 라이브러리 사용 예제 : 최대 힙</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> heapq\n\n<span class=\"token comment\">#내림차순 힙 정렬(Haep Sort)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">heapsort</span><span class=\"token punctuation\">(</span>iterable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    h <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 모든 원소를 차례대로 힙에 삽입</span>\n    <span class=\"token keyword\">for</span> value <span class=\"token keyword\">in</span> iterable<span class=\"token punctuation\">:</span>\n        heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span>value<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">#힙에 삽입된 모든 원소를 차례대로 꺼내어 담기</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        result<span class=\"token punctuation\">.</span>apeend<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> result\n\nresult <span class=\"token operator\">=</span> heapsort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>다익스트라 알고리즘 : 개선된 구현 방법</p>\n<ul>\n<li>단계마다 <u>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택</u>하기 위해 <strong>힙(Heap)</strong> 자료구조를 이용한다.</li>\n<li>\n<p>다익스트라 알고리즘이 동작하는 <strong>기본  원리는 동일</strong>하다.</p>\n<ul>\n<li>현재 가장 가까운 노드를 저장해 놓기 위해서 힙 자료구조를 추가적으로 이용한다는 점이 다르다.</li>\n<li>현재의 최단 거리가 가장 짧은 노드를 선택해야 하므로 최소 힙을 이용한다.</li>\n</ul>\n</li>\n<li>동작 과정 살펴보기(우선순위 큐)\n<img src=\"https://user-images.githubusercontent.com/71132893/103744352-fc8a8e80-5040-11eb-94d2-0cd20f500322.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103744418-1b892080-5041-11eb-90af-b5fc39db79af.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103744508-41162a00-5041-11eb-92c7-ea36b8ef03df.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103744575-5c813500-5041-11eb-8bc8-98a08ab697af.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103744615-6efb6e80-5041-11eb-97f4-a996a84a5e31.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103744651-7c185d80-5041-11eb-853c-e13f1ba7f7b2.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103744686-89cde300-5041-11eb-8c79-0089bd29de02.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103744714-96523b80-5041-11eb-993d-784dc2aeb126.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/71132893/103744752-a702b180-5041-11eb-8f14-e21f7d737a89.png\" alt=\"image\"></li>\n<li>\n<p>동작 예시(Python)</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> heapq\n<span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span></code></pre></div>\n</li>\n</ul>\n<h1>노드의 개수, 간선의 개수를 입력받기</h1>\n<p>n, m = map(int, input().split())</p>\n<h1>시작 노드 번호를 입력받기</h1>\n<p>start = int(input())</p>\n<h1>각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기</h1>\n<p>graph = [[] for i in range(n + 1)]</p>\n<h1>최단 거리 테이블을 모두 무한으로 초기화</h1>\n<p>distance = [INF] * (n + 1)</p>\n<h1>모든 간선 정보를 입력받기</h1>\n<p>for _ in range(m):\na, b, c = map(int, input().split())\n# a번 노드에서 b번 노드로 가는 비용이 c라는 의미\ngraph[a].append((b, c))</p>\n<p>def dijkstra(start):\nq = []\n# 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입\nheapq.heappush(q, (0, start))\ndistance[start] = 0\nwhile q: # 큐가 비어있지 않다면\n# 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기\ndist, now = heapq.heappop(q)\n# 현재 노드가 이미 처리된 적이 있는 노드라면 무시\nif distance[now] &#x3C; dist:\ncontinue\n# 현재 노드와 연결된 다른 인접한 노드들을 확인\nfor i in graph[now]:\ncost = dist + i[1]\n# 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우\nif cost &#x3C; distance[i[0]]:\ndistance[i[0]] = cost\nheapq.heappush(q, (cost, i[0]))</p>\n<h1>다익스트라 알고리즘을 수행</h1>\n<p>dijkstra(start)</p>\n<h1>모든 노드로 가기 위한 최단 거리를 출력</h1>\n<p>for i in range(1, n + 1):\n# 도달할 수 없는 경우, 무한(INFINITY)이라고 출력\nif distance[i] == INF:\nprint(\"INFINITY\")\n# 도달할 수 있는 경우 거리를 출력\nelse:\nprint(distance[i])</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 개선된 구현 방법 성능 분석\n    - 힙 자료구조를 이용하는 다익스트라 알고리즘의 시간 복잡도는 *O(ElogV)*이다.\n    - 노드를 하나씩 꺼내 검사하는 반복문(while문)은 노드의 개수 V 이상의 횟수로는 처리되지 않는다.\n        - 결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총횟수는 최대 간선의 개수(E)만큼 연산이 수행될 수 있다.\n    - 직관적으로 &lt;u&gt;전체 과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사&lt;/u&gt;하다.\n        - 시간 복잡도를 *O(ElogE)*로 판단할 수 있다.\n        - 중복 간선을 포함하지 않은 경우에 이를 *O(ElogV)*로 정리할 수 있다.\n            - *O*(*ElogE*) -&gt; *O*(*ElogV&lt;sup&gt;2&lt;/sup&gt;*) -&gt; *O*(*2ElogV*) -&gt; *O*(*ElogV*)</code></pre></div>\n</li>\n</ul>","frontmatter":{"title":"알고리즘 공부 기록/강의7-1","date":"06 January, 2020"}}},"pageContext":{"slug":"/lecture7-1/"}},"staticQueryHashes":[]}