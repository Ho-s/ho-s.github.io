{"componentChunkName":"component---markdown-template-js","path":"/lecture3-1/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"3-1-큐-스택-재귀함수\" style=\"position:relative;\"><a href=\"#3-1-%ED%81%90-%EC%8A%A4%ED%83%9D-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98\" aria-label=\"3 1 큐 스택 재귀함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. 큐, 스택, 재귀함수</h2>\n<h3 id=\"그래프-탐색-알고리즘--dfsbfs\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98--dfsbfs\" aria-label=\"그래프 탐색 알고리즘  dfsbfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래프 탐색 알고리즘 : DFS/BFS</h3>\n<ul>\n<li>탐색(Search)이란 많은 양의 데이터 중에서 <strong>원하는 데이터를 찾는 과정</strong>을 말함.</li>\n<li>대표적인 그래프 탐색 알고리즘으로는 DFS와 BFS가 있음.</li>\n<li>DFS/BFS는 코딩테스트에서 매우 자주 등장하는 유형이므로 필히 숙지가 요구됨.</li>\n</ul>\n<h3 id=\"스택-자료구조\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9D-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"스택 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택 자료구조</h3>\n<ul>\n<li>먼저 들어온 데이터가 나중에 나가는 형식(선입후출)의 자료구조</li>\n<li><strong>입구와 출구가 동일한 형태</strong>로 스택을 시각화할 수 있음.<br>\n<img src=\"https://user-images.githubusercontent.com/71132893/103338205-02bcc000-4ac1-11eb-8fdb-733b8a41203c.png\" alt=\"image\"></li>\n<li>스택 구현 예제(Python)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">stack<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 삽입 - 삽입 - 삽입 - 삽입 - 삭제 - 삽입 - 삽입 - 삭제</span>\nstack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\nstack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\nstack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\nstack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span>\nstack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nstack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nstack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\nstack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#최상단 원소부터 출력 출력 결과 : [1,3,2,5]</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">)</span> <span class=\"token comment\">#최하단 원소부터 출력 출력 결과 : [5,2,3,1]</span></code></pre></div>\n<h3 id=\"큐-자료구조\" style=\"position:relative;\"><a href=\"#%ED%81%90-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"큐 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>큐 자료구조</h3>\n<ul>\n<li>먼저 들어온 데이터가 먼저 나가는 형식(선입선출)의 자료구조</li>\n<li>큐는 <strong>입구와 출구가 모두 뚫려있는 터널과 같은 형태</strong>로 시각화 할 수 있음.\n<img src=\"https://user-images.githubusercontent.com/71132893/103338602-3cda9180-4ac2-11eb-9113-5a43adda39fd.png\" alt=\"image\"></li>\n<li>큐 구현 예제(python)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n\n<span class=\"token comment\">#큐 구현을 위해 deque라이브러리 사용</span>\nqueue<span class=\"token operator\">=</span>deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 삽입 - 삽입 - 삽입 - 삽입 - 삭제 - 삽입 - 삽입 - 삭제</span>\nqueue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\nqueue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\nqueue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\nqueue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span>\nqueue<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nqueue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nqueue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\nqueue<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span> <span class=\"token comment\">#먼저 들어온 순서대로 출력 결과:deque([3,7,1,4])</span>\nqueue<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#역순으로 바꾸기</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span> <span class=\"token comment\">#먼저 들어온 순서대로 출력 결과:deque([4,1,7,3])</span></code></pre></div>\n<h3 id=\"재귀-함수\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80-%ED%95%A8%EC%88%98\" aria-label=\"재귀 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀 함수</h3>\n<ul>\n<li>재귀 함수(Recursive Function)란 <span style='color:violet'>자기 자신을 다시 호출하는 함수</span>를 의미함</li>\n<li>단순한 형태의 재귀 함수 예제</li>\n<li>'재귀 함수를 호출합니다.'라는 문자열을 무한히 출력</li>\n<li>어느정도 출력하다가 최대 재귀 깊이 초과 메시지가 출력됨</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">recursive_function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'재귀 함수를 호출합니다.'</span><span class=\"token punctuation\">)</span>\n    recursive_function<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nrecursive_function<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>\n<p>재귀 함수의 종료 조건</p>\n<ul>\n<li>재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야 함.</li>\n<li>종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출될 수 있음.</li>\n<li>종료 조건을 포함한 재귀 함수 예제</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">recursive_function</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\">#100번째 호출을 했을 때 종료 조건 명시</span>\n    <span class=\"token keyword\">if</span> i <span class=\"token operator\">==</span> <span class=\"token number\">100</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token string\">'번째 재귀함수에서'</span> <span class=\"token punctuation\">,</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'번째 재귀 함수를 호출합니다.'</span><span class=\"token punctuation\">)</span>\n    recursive_function<span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span><span class=\"token string\">'번째 재귀함수를 종료합니다'</span><span class=\"token punctuation\">)</span>\nrecursive_function<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>팩토리얼 구현 예제</p>\n<ul>\n<li>n! = 1 X 2 X 3 X ... X (n-1) X n</li>\n<li>수학적으로 0!과 1!의 값은 1임.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 반복적으로 구현한 n!</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">factorial_iterative</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    result<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n    <span class=\"token comment\"># 1부터 n까지의 수를 차례대로 곱하기</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        result <span class=\"token operator\">*=</span>i\n        <span class=\"token keyword\">return</span> result\n\n<span class=\"token comment\"># 재귀적으로 구현한 n!</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">factorial_recursive</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n<span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> <span class=\"token comment\">#n이 1이하인 경우 1을 반환</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n    <span class=\"token comment\">#n! =n*(n-1)!을 그대로 코드로 작성하기</span>\n    <span class=\"token keyword\">return</span> n<span class=\"token operator\">*</span>factorial_recursive<span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">#각각의 방식으로 구현한 n! 출력 (n=5)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'반복적으로 구현:'</span><span class=\"token punctuation\">,</span>factorial_iterative<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'재귀적으로 구현:'</span><span class=\"token punctuation\">,</span>factorial_recursive<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>최대 공약수 계산(유클리드 호제법)예제</p>\n<ul>\n<li><u>두개의 자연수에 대한 최대공약수</u>를 구하는 대표적인 알고리즘으로는 유클리드 호제법이 있음</li>\n<li>\n<p><strong>유클리드 호제법</strong></p>\n<ol>\n<li>두 자연수 A,B에 대하여(A>B) A를 B로 나눈 나머지를 R이라고 하고,</li>\n<li>이때 A와 B의 최대 공약수는 B와 R의 최대 공약수와 같음.</li>\n</ol>\n</li>\n<li>유클리드 호제법의 아이디어를 그대로 재귀 함수로 작성할 수 있음.\n<img src=\"https://user-images.githubusercontent.com/71132893/103349572-876b0680-4ae0-11eb-93b7-a238b17a43c4.png\" alt=\"image\"></li>\n<li>\n<p>예제(python)</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n<span class=\"token keyword\">if</span> a<span class=\"token operator\">%</span>b<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> b\n<span class=\"token keyword\">else</span> <span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> gcd<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span>a<span class=\"token operator\">%</span>b<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>gcd<span class=\"token punctuation\">(</span><span class=\"token number\">192</span><span class=\"token punctuation\">,</span><span class=\"token number\">162</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 실행 결과 : 6</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>재귀함수 사용의 유의 사항</p>\n<ul>\n<li>\n<p>재귀 함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있음.</p>\n<ul>\n<li>단, 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수도 있으므로 신중하게 사용해야 함.</li>\n</ul>\n</li>\n<li>모든 <u>재귀 함수는 반복문을 이용하여 동일한 기능을 구현</u>할 수 있음.</li>\n<li>재귀 함수가 반복문보다 유리한 경우도 있고, 불리한 경우도 있음.</li>\n<li>\n<p>컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓임.</p>\n<ul>\n<li>그래서 스택을 사용해야 할 때 구현상 <strong>스택 라이브러리 대신에 재귀함수를 이용</strong>하는 경우가 많음.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"알고리즘 공부 기록/강의3-1","date":"30 December, 2020"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#3-1-%ED%81%90-%EC%8A%A4%ED%83%9D-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98\">3-1. 큐, 스택, 재귀함수</a></p>\n<ul>\n<li><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98--dfsbfs\">그래프 탐색 알고리즘 : DFS/BFS</a></li>\n<li><a href=\"#%EC%8A%A4%ED%83%9D-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\">스택 자료구조</a></li>\n<li><a href=\"#%ED%81%90-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\">큐 자료구조</a></li>\n<li><a href=\"#%EC%9E%AC%EA%B7%80-%ED%95%A8%EC%88%98\">재귀 함수</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"slug":"/lecture3-1/"}},"staticQueryHashes":[]}